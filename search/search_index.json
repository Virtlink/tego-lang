{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tego \u00b6 Tego is a lazy function language that compiles to Java bytecode. Its primary use is to specify search strategies for the implementation of various editor services. Tego is experimental and still work-in-progress. Its syntax and implementation are not stable yet, and it lacks documentation, test coverage, and benchmarks. The documentation is split into these parts: Getting Started : installation, download links, changelogs, and migration guides. Tutorials : hands-on tutorials to get you working with Tego. How-tos : step-by-step guides showing how to achieve certain goals. Reference : technical reference describing the various facets. Background : background information and discussion on various key topics. Develop : reference for Tego developers.","title":"Home"},{"location":"#tego","text":"Tego is a lazy function language that compiles to Java bytecode. Its primary use is to specify search strategies for the implementation of various editor services. Tego is experimental and still work-in-progress. Its syntax and implementation are not stable yet, and it lacks documentation, test coverage, and benchmarks. The documentation is split into these parts: Getting Started : installation, download links, changelogs, and migration guides. Tutorials : hands-on tutorials to get you working with Tego. How-tos : step-by-step guides showing how to achieve certain goals. Reference : technical reference describing the various facets. Background : background information and discussion on various key topics. Develop : reference for Tego developers.","title":"Tego"},{"location":"compiler/","text":"Tego Compiler \u00b6 Each strategy is compiled to a Java class that returns its results lazily. To achieve this, the compiler performs the following steps: Convert to ANF Build state machine Generate bytecode We use this example: decl generate<T>(T -> T): T -> [T] generate(s) i = v := <s> i; ![v | <generate(s)> v]. Convert to ANF \u00b6 The first step of the compilation algorithm is to convert the strategy expressions into an intermediate representation known as Administrative Normal Form (ANF). This ensures almost all expressions only operate on immediate expressions. Immediate expressions are expressions for which no further computation is necessary, such as a constant value or a variable reference. To represent the expressions in ANF, we define the following IR expressions: v \\ Returns the value of variable v . let v = e in b \\ Evaluates e , assigns it to variable v in the scope of b , and returns the value of evaluating b . lam (p1: T1, p2: T2, ..) TO = b \\ Returns a lambda function with parameters p1 , p2 , ... (of types T1 , T2 , ...) and body b that returns a value of type TO . [lazy] strategy (p1: T1, p2: T2, ..) i: TI -> TO = b \\ Returns a lambda strategy with parameters p1 , p2 , ... (of types T1 , T2 , ...) and body b that takes a value of type TI and returns a value of type TO . When the strategy is marked lazy , it returns its results lazily. s(a1, a2, ..) \\ Applies arguments a1 , a2 , ... to strategy s , returning a strategy of type TI -> TO . <s> i \\ (Maybe lazy.) Evaluates strategy s with input argument i , returning a value of the strategy's return type. yield(v) \\ (Lazy.) Yields the value of v . yieldAll(vs) \\ (Lazy.) Yields the values of v . The generate strategy is represented in ANF as follows: strategy (s: T -> T) i: T -> [T] = let v = <s> i in let tl = <generate(s)> v in let l = [v | lt] in let r = build(l) in let sr = <r> i in sr This computes the sequence sr eagerly and returns it. However, to perform lazy evaluation, instead of computing the sequence and returning it, we should return a sequence that knows how to compute itself. The generate strategy is represented in ANF as follows: lazy strategy (s: T -> T) i: T -> [T] = let v = <s> i in let tl = <generate(s)> v in let l = [v | lt] in let r = build(l) in let sr = <r> i in yieldAll(sr) Note that we end the strategy by applying r to i and yielding its results. This forces evaluation of the strategy r that we built, and returns the sequence of results. Continuations \u00b6 The trick to lazy evaluation is continuations. The above lazy strategy can be rewritten to accept a continuation, which is a function that takes the result of the strategy and do something with it. strategy (s: T -> T, cont: (T) -> ()) i: T -> [T] = let v = <s> i in let tl = <generate(s)> v in let l = [v | lt] in let r = build(l) in let sr = <r> i in yieldAll(sr, cont) Build a State Machine \u00b6 The above ANF is sufficient to generate an eager implementation of the strategy. But to generate a lazy implementation, we need to recognize that every time we return a result, the computation can be suspended. To achieve this, we use coroutines and a state machine. Instead of computing the whole list of values at once (which is impossible for our infinitely recursive definition of generate ), we compute the list lazily. We dictate that strategies can be suspended (using Kotlin terminology) and a given strategy run sequentially from suspension point to suspension point (that is, from strategy evaluation to strategy evaluation). This is the above example ANF with its suspension points indicated: lazy strategy (s: T -> T) i: T -> [T] = let v = <s> i in // suspension point let tl = <generate(s)> v in // suspension point let l = [v | lt] in let r = build(l) in let sr = <r> i in // suspension point yieldAll(sr) // suspension point The state machine generates a label for the start of each sequential block. lazy strategy (s: T -> T) i: T -> [T] = label l0: let v = <s> i in // suspension point label l1: let tl = <generate(s)> v in // suspension point label l2: let l = [v | lt] in let r = build(l) in let sr = <r> i in // suspension point label l3: yieldAll(sr) // suspension point label l4: And a con","title":"Tego Compiler"},{"location":"compiler/#tego-compiler","text":"Each strategy is compiled to a Java class that returns its results lazily. To achieve this, the compiler performs the following steps: Convert to ANF Build state machine Generate bytecode We use this example: decl generate<T>(T -> T): T -> [T] generate(s) i = v := <s> i; ![v | <generate(s)> v].","title":"Tego Compiler"},{"location":"compiler/#convert-to-anf","text":"The first step of the compilation algorithm is to convert the strategy expressions into an intermediate representation known as Administrative Normal Form (ANF). This ensures almost all expressions only operate on immediate expressions. Immediate expressions are expressions for which no further computation is necessary, such as a constant value or a variable reference. To represent the expressions in ANF, we define the following IR expressions: v \\ Returns the value of variable v . let v = e in b \\ Evaluates e , assigns it to variable v in the scope of b , and returns the value of evaluating b . lam (p1: T1, p2: T2, ..) TO = b \\ Returns a lambda function with parameters p1 , p2 , ... (of types T1 , T2 , ...) and body b that returns a value of type TO . [lazy] strategy (p1: T1, p2: T2, ..) i: TI -> TO = b \\ Returns a lambda strategy with parameters p1 , p2 , ... (of types T1 , T2 , ...) and body b that takes a value of type TI and returns a value of type TO . When the strategy is marked lazy , it returns its results lazily. s(a1, a2, ..) \\ Applies arguments a1 , a2 , ... to strategy s , returning a strategy of type TI -> TO . <s> i \\ (Maybe lazy.) Evaluates strategy s with input argument i , returning a value of the strategy's return type. yield(v) \\ (Lazy.) Yields the value of v . yieldAll(vs) \\ (Lazy.) Yields the values of v . The generate strategy is represented in ANF as follows: strategy (s: T -> T) i: T -> [T] = let v = <s> i in let tl = <generate(s)> v in let l = [v | lt] in let r = build(l) in let sr = <r> i in sr This computes the sequence sr eagerly and returns it. However, to perform lazy evaluation, instead of computing the sequence and returning it, we should return a sequence that knows how to compute itself. The generate strategy is represented in ANF as follows: lazy strategy (s: T -> T) i: T -> [T] = let v = <s> i in let tl = <generate(s)> v in let l = [v | lt] in let r = build(l) in let sr = <r> i in yieldAll(sr) Note that we end the strategy by applying r to i and yielding its results. This forces evaluation of the strategy r that we built, and returns the sequence of results.","title":"Convert to ANF"},{"location":"compiler/#continuations","text":"The trick to lazy evaluation is continuations. The above lazy strategy can be rewritten to accept a continuation, which is a function that takes the result of the strategy and do something with it. strategy (s: T -> T, cont: (T) -> ()) i: T -> [T] = let v = <s> i in let tl = <generate(s)> v in let l = [v | lt] in let r = build(l) in let sr = <r> i in yieldAll(sr, cont)","title":"Continuations"},{"location":"compiler/#build-a-state-machine","text":"The above ANF is sufficient to generate an eager implementation of the strategy. But to generate a lazy implementation, we need to recognize that every time we return a result, the computation can be suspended. To achieve this, we use coroutines and a state machine. Instead of computing the whole list of values at once (which is impossible for our infinitely recursive definition of generate ), we compute the list lazily. We dictate that strategies can be suspended (using Kotlin terminology) and a given strategy run sequentially from suspension point to suspension point (that is, from strategy evaluation to strategy evaluation). This is the above example ANF with its suspension points indicated: lazy strategy (s: T -> T) i: T -> [T] = let v = <s> i in // suspension point let tl = <generate(s)> v in // suspension point let l = [v | lt] in let r = build(l) in let sr = <r> i in // suspension point yieldAll(sr) // suspension point The state machine generates a label for the start of each sequential block. lazy strategy (s: T -> T) i: T -> [T] = label l0: let v = <s> i in // suspension point label l1: let tl = <generate(s)> v in // suspension point label l2: let l = [v | lt] in let r = build(l) in let sr = <r> i in // suspension point label l3: yieldAll(sr) // suspension point label l4: And a con","title":"Build a State Machine"},{"location":"continuation-passing-style/","text":"Continuation Passing Style (CPS) and Administrative Normal Form (ANF) \u00b6 Continuation passing style (CPS) explicitly encodes the control flow of the program. Instead of returning a value, throwing an exception, or jumping to labels in a loop, a program in CPS calls a continuation function that handles the value or exception. However, writing CPS programs by hand is unintuitive and error-prone, and it considerably increases the size of programs. But CPS can be very useful as the intermediate representation of a program in a compiler. Flanagan et. al. (1993) recognize that typically compilers do a transformation to CPS, followed by a simplification, followed by a transformation to un-CPS, and that these steps can be performed at once using Administrative Normal Form (A-Normal Form, or ANF). Continuations \u00b6 A function in Continuation Passing Style (CPS) never returns its result, but always uses a continuation to communicate the result. The function has an extra continuation parameter, which is a callback function that takes a single argument of the type that the function used to return. Most continuation calls would be tail calls (i.e., the last call in the function, as they replace the function's return ), and can be optimized in various ways (such as not allocating a new stack frame for the continuation call, or rewriting a tail recursive function into a loop). While in direct style the caller decides what happens after the called function terminates, in CPS the callee decides this. Note that since the callee calls the continuation to continue but never returns, the call stack only grows. A function in CPS can take more than one continuation. For example, one continuation for normal control flow (i.e., return ), another for exceptional control flow (i.e., throw ). While in general continuation could be invoked multiple times ( multi-shot ), often it is fine to have continuations that can only be invoked once ( single-shot or one-shot ). Call/cc (call-with-current-continuation) is a control operator that captures the rest of the program in a continuation. Calling the captured continuation can't return values, because it can only resume the rest of the program until it completes. This is known as an undelimited continuation . An example of a undelimited continuation is in this product function, which calls the continuation k when it encounters a 0 to break out early. callCC captures the current stack, and a call to k resumes as if the given value was provided instead of the callCC . public decl product : [Int] -> Int product l -> <callCC> \\k -> loop(k) l\\ decl loop(Int -> Nothing) : [Int] -> Int loop(_) [] -> 1 loop(k) [0|_] -> <k> 0 loop(k) [x|xs] -> xsn := <loop(k)> xs; <mul> (x, xsn) See Also \u00b6 Marijn Haverbeke \u2014 Continuation-Passing Style and why JavaScript developers might be interested in it Yassine Elouafi \u2014 Algebraic Effects in JavaScript Continuations and Control Transfer Capturing Continuations with Generators Delimited Continuations Implementing Algebraic Effects and Handlers ANF \u00b6 In ANF, the arguments to a function must be immediate values. Immediate values do not need any computation; they are constants or can be looked up in the environment. For example, the expression: 2 + 2 + let x = 1 in f(x) Is normalized to ANF as: let t1 = 2 + 2 in let x = 1 in let t2 = f(x) in t1 + t2 Bytecode generation is easier, since the simple operations can be encoded in a few bytecode instructions: // let t1 = 2 + 2 in LOADC 2 LOADC 2 ADD STORE t1 // let x = 1 in LOADC 1 STORE x // let t2 = f(x) in LOAD f LOAD x CALL STORE t2 // t1 + t2 LOAD t1 LOAD t2 ADD Control Flow \u00b6 While most arguments in ANF are immediate values, control flow is modeled using non-immediate values. For example, the if -expression: if (c) e1 else e2 Here c is an immediate value, but e1 and e2 are not. For example: x = if (f()) a() else b() Would be translated in ANF to: let c = f() in let x = if (c) a() else b() And not into: let c = f() in let a' = a() in let b' = b() in let x = if (c) a' else b' Because in the latter case a() and b() would both be evaluated. See Also \u00b6 Flanagan et. al. (PLDI'93) \u2014 The Essence of Compiling with Continuations Kennedy (ICFP'07) \u2014 Compiling with Continuations, Continued Maurer (2015) \u2014 Intermediate Languages for Optimization Maurer et. al. (2016) \u2014 Administrative Normal Form, Continued Maurer et. al. (PLDI'17) \u2014 Compiling without Continuations Cong et. al. (ICFP'19) \u2014 Compiling with Continuations, or without? Whatever. Might \u2014 A-Normalization: Why and How Might \u2014 Writing an interpreter, CESK-style (Swarthmore) ANF Conditionals and A-Normal Form Revisiting ANF: Encoding A-Normal Form with Types Program transformations in Hakaru Haskell - STG","title":"Continuation Passing Style (CPS) and Administrative Normal Form (ANF)"},{"location":"continuation-passing-style/#continuation-passing-style-cps-and-administrative-normal-form-anf","text":"Continuation passing style (CPS) explicitly encodes the control flow of the program. Instead of returning a value, throwing an exception, or jumping to labels in a loop, a program in CPS calls a continuation function that handles the value or exception. However, writing CPS programs by hand is unintuitive and error-prone, and it considerably increases the size of programs. But CPS can be very useful as the intermediate representation of a program in a compiler. Flanagan et. al. (1993) recognize that typically compilers do a transformation to CPS, followed by a simplification, followed by a transformation to un-CPS, and that these steps can be performed at once using Administrative Normal Form (A-Normal Form, or ANF).","title":"Continuation Passing Style (CPS) and Administrative Normal Form (ANF)"},{"location":"continuation-passing-style/#continuations","text":"A function in Continuation Passing Style (CPS) never returns its result, but always uses a continuation to communicate the result. The function has an extra continuation parameter, which is a callback function that takes a single argument of the type that the function used to return. Most continuation calls would be tail calls (i.e., the last call in the function, as they replace the function's return ), and can be optimized in various ways (such as not allocating a new stack frame for the continuation call, or rewriting a tail recursive function into a loop). While in direct style the caller decides what happens after the called function terminates, in CPS the callee decides this. Note that since the callee calls the continuation to continue but never returns, the call stack only grows. A function in CPS can take more than one continuation. For example, one continuation for normal control flow (i.e., return ), another for exceptional control flow (i.e., throw ). While in general continuation could be invoked multiple times ( multi-shot ), often it is fine to have continuations that can only be invoked once ( single-shot or one-shot ). Call/cc (call-with-current-continuation) is a control operator that captures the rest of the program in a continuation. Calling the captured continuation can't return values, because it can only resume the rest of the program until it completes. This is known as an undelimited continuation . An example of a undelimited continuation is in this product function, which calls the continuation k when it encounters a 0 to break out early. callCC captures the current stack, and a call to k resumes as if the given value was provided instead of the callCC . public decl product : [Int] -> Int product l -> <callCC> \\k -> loop(k) l\\ decl loop(Int -> Nothing) : [Int] -> Int loop(_) [] -> 1 loop(k) [0|_] -> <k> 0 loop(k) [x|xs] -> xsn := <loop(k)> xs; <mul> (x, xsn)","title":"Continuations"},{"location":"continuation-passing-style/#see-also","text":"Marijn Haverbeke \u2014 Continuation-Passing Style and why JavaScript developers might be interested in it Yassine Elouafi \u2014 Algebraic Effects in JavaScript Continuations and Control Transfer Capturing Continuations with Generators Delimited Continuations Implementing Algebraic Effects and Handlers","title":"See Also"},{"location":"continuation-passing-style/#anf","text":"In ANF, the arguments to a function must be immediate values. Immediate values do not need any computation; they are constants or can be looked up in the environment. For example, the expression: 2 + 2 + let x = 1 in f(x) Is normalized to ANF as: let t1 = 2 + 2 in let x = 1 in let t2 = f(x) in t1 + t2 Bytecode generation is easier, since the simple operations can be encoded in a few bytecode instructions: // let t1 = 2 + 2 in LOADC 2 LOADC 2 ADD STORE t1 // let x = 1 in LOADC 1 STORE x // let t2 = f(x) in LOAD f LOAD x CALL STORE t2 // t1 + t2 LOAD t1 LOAD t2 ADD","title":"ANF"},{"location":"continuation-passing-style/#control-flow","text":"While most arguments in ANF are immediate values, control flow is modeled using non-immediate values. For example, the if -expression: if (c) e1 else e2 Here c is an immediate value, but e1 and e2 are not. For example: x = if (f()) a() else b() Would be translated in ANF to: let c = f() in let x = if (c) a() else b() And not into: let c = f() in let a' = a() in let b' = b() in let x = if (c) a' else b' Because in the latter case a() and b() would both be evaluated.","title":"Control Flow"},{"location":"continuation-passing-style/#see-also_1","text":"Flanagan et. al. (PLDI'93) \u2014 The Essence of Compiling with Continuations Kennedy (ICFP'07) \u2014 Compiling with Continuations, Continued Maurer (2015) \u2014 Intermediate Languages for Optimization Maurer et. al. (2016) \u2014 Administrative Normal Form, Continued Maurer et. al. (PLDI'17) \u2014 Compiling without Continuations Cong et. al. (ICFP'19) \u2014 Compiling with Continuations, or without? Whatever. Might \u2014 A-Normalization: Why and How Might \u2014 Writing an interpreter, CESK-style (Swarthmore) ANF Conditionals and A-Normal Form Revisiting ANF: Encoding A-Normal Form with Types Program transformations in Hakaru Haskell - STG","title":"See Also"},{"location":"coroutines/","text":"Coroutines \u00b6 Continuations that are used to implement cooperative scheduling are called coroutines . The trick to performing lazy (and possibly asynchronous) computation in Java is to explicitly encode the control flow. Instead of letting a function simply run to its end and return, we rewrite the method to use continuation passing style and provide it with a continuation that handles the result. This way, we can pause execution any time we want, and call the continuation as soon as we want to continue (as the name implies). Imagine a function updatePerson , which loads a person's record using its ID, updates its name, and saves the record again. The function returns the timestamp of when the record was saved. long updatePerson ( int id , String name ) { System . out . println ( \"Updating person with ID: \" + id ); Person person = personRepository . get ( id ); person . name = name ; long timestamp = personRepository . save ( id , person ); System . out . println ( \"Updated at: \" + timestamp ); return timestamp ; } We would call this function like this: long result = updatePerson ( 10 , \"Aya\" ); Now we want to rewrite updatePerson as a coroutine, i.e. a computation that can be suspended. We do this using continuation-passing style (CPS). We explicitly provide a continuation that the function should call to continue execution. The continuation represents the rest of the computation to be performed once this computation is done. So we change the signature to accept the continuation as the last parameter. Also, the function should no longer return its result though return , but instead by calling the continuation. void updatePerson ( int id , String name , Consumer < Long > onCompletion ) { System . out . println ( \"Updating person with ID: \" + id ); Person person = personRepository . get ( id ); person . name = name ; long timestamp = personRepository . save ( id , person ); System . out . println ( \"Updated at: \" + timestamp ); onCompletion . accept ( timestamp ); } We can call this modified updatePerson function by providing the continuation: long result ; updatePerson ( 10 , \"Daniel\" , r -> { result = r ; }); Of course, this coroutine is not very lazy yet. It can call other coroutines, so let's assume that the methods on the personRepository are also coroutines. Therefore, we need to provide them with continuations. We will tackle this next. CPS \u00b6 If personRepository.get() and personRepository.save() are coroutines, we need to provide them with a continuation that they can call. We can do this by splitting our function up into separate function steps like this: void updatePerson ( int id , String name , Consumer < Long > onCompletion ) { // Start System . out . println ( \"Updating person with ID: \" + id ); personRepository . get ( id , ( result ) -> updatePerson2 ( id , name , onCompletion , result ) ); } void updatePerson2 ( int id , String name , Consumer < Long > onCompletion , Person result ){ // Step 2 Person person = result ; person . name = name ; personRepository . save ( id , person , ( result ) -> updatePerson3 ( id , name , person , onCompletion , result ) ); } void updatePerson3 ( int id , String name , Person person , Consumer < Long > onCompletion , long result ){ // Step 3 long timestamp = result ; System . out . println ( \"Updated at: \" + timestamp ); onCompletion . accept ( timestamp ); } Note that the coroutine is called as the last action in each function step. This means that they can take advantage of tail call optimization to avoid creating a new stack frame for each coroutine or continuation call. But tail call optimization has its own downsides: it will appear as if the calls in between never happened, which makes debugging, stack tracing, and access control more difficult. Also note that the above example creates a new closure for every continuation, and finally but most importantly, Java does not support tail call optimization at all. State Machine \u00b6 Let's see if we can solve some of these problems. Firstly, let's reduce the number of objects that are needed for representing continuations, because if we were to execute a coroutine in a loop, we would end up with a lot of continuation closure objects. One way to solve this is to create a state machine, which takes the place of each of the continuations. To call the correct function step, we need to track which step we expect to execute next. Additionally, to provide the arguments and local variables to the call, we store them in the state machine. class updatePerson_StateMachine implements Consumer < Object > { // Arguments Test $this ; int id ; String name ; // Local variables Person person ; long timestamp ; // State Machine updatePerson_State state ; Function < Object , Object > onCompletion ; updatePerson_StateMachine ( Function < Object , Object > onCompletion ) { this . onCompletion = onCompletion ; } @Override public void accept ( Object result ) { switch ( state ) { case Start : throw new IllegalStateException (); case Step2 : $this . updatePerson2 ( id , name , this , result ); break ; case Step3 : $this . updatePerson3 ( id , name , person , this , result ); break ; default : throw new IllegalStateException (); } } } enum updatePerson_State { Start , Step2 , Step3 , Done , } The state machine class is relatively straightforward. Being a state machine, it has to store the current state in its state field. The state determines at which function step will resume when the state machine is used as a continuation. Because we reuse the state machine object, it will get return values of different types after each suspending function. Therefore, it has type Consumer<Object> , accepting any object (including null ). It would be used as a continuation like this: void updatePerson ( int id , String name , Consumer < Long > onCompletion ) { // Start // Create state machine updatePerson_StateMachine cont = new updatePerson_StateMachine ( onCompletion ); System . out . println ( \"Updating person with ID: \" + id ); // Store arguments cont . id = id ; cont . name = name ; // Call coroutine cont . state = updatePerson_State . Step2 ; personRepository . get ( id , cont ); } void updatePerson2 ( int id , String name , updatePerson_StateMachine cont , Person result ){ // Step 2 Person person = result ; person . name = name ; // Store local variables cont . person = person ; // Call coroutine cont . state = updatePerson_State . Step3 ; personRepository . save ( id , person , cont ); } void updatePerson3 ( int id , String name , Person person , updatePerson_StateMachine cont , long result ){ // Step 3 long timestamp = result ; System . out . println ( \"Updated at: \" + timestamp ); cont . onCompletion . accept ( timestamp ); } Here we make the implicit assumption that the state machine continuation is only called zero or one time. If the same continuation would be called more than once, then the stored local variables and next state might go wrong. Single Function \u00b6 Our coroutine is still split across functions, which makes it harder to debug and stack trace. We can improve this by putting the different function steps back into one function, and using the state machine's state to jump to the correct piece of code. The function needs to determine whether it is being called for the first time (using some other continuation), or being resumed (using the state machine as the continuation). If it is being resumed, it will be given the state machine as its continuation. Otherwise, if this is the first call, it will be given another continuation, and we should instantiate a new state machine and store the arguments and continuation in it. void updatePerson ( int id , String name , Consumer < Object > onCompletion ) { // Get the state machine updatePerson_StateMachine cont ; if ( onCompletion instanceof updatePerson_StateMachine ) { // Resumed from a previous call cont = ( updatePerson_StateMachine ) onCompletion ; } else { // Called for the first time cont = new updatePerson_StateMachine ( onCompletion ); // Store the arguments cont . $this = this ; cont . id = id ; cont . name = name ; } Recursive calls How do we distinguish a direct recursive call to the coroutine (providing the state machine of the parent call as the continuation) from a resumed call (providing the state machine of this call as the continuation)? The next step is to decide where to resume to. If we somehow ended up in an illegal state, we throw an exception. Person person ; long timestamp ; Object result = cont . result ; // Decide where to resume if ( cont . state == Start ) goto block0 ; if ( cont . state == Step1 ) goto block1 ; if ( cont . state == Step2 ) goto block2 ; throw new IllegalStateException (); Each resumption point has to start with restoring the local variables from the saved state. block0 : // Restore local variables person = cont . person ; timestamp = cont . timestamp ; The next code is just the sequential code in between two coroutines. Since we reinstated the arguments and restored local variables, this should be straightforward. System . out . println ( \"Updating person with ID: \" + id ); Now we end the block with a call to another coroutine. Just before the call we should store the changed local variables (if any), and update the state field to get us to the next step once the continuation is called. // Call coroutine cont . state = updatePerson_State . Step1 ; personRepository . get ( id , cont ); // coroutine We can exit this function now. Execution will resume from the next block when the continuation is called. // Done. return ; Upon entering the next step, it should restore the local variables (if any) and handle the result provided to the continuation, the result returned by the coroutine that was called previously. Note that since the result is not provided explicitly as an argument to the function, we store it in the state machine continuation instead. block1 : // Handle the previous result person = ( Person ) result ; This is also where we would assign it to a variable. Note that the initial step is not expecting any results yet (because we didn't end up here through calling a coroutine), but later steps do. The rest of the code is straightforward: person . name = name ; // Store local variables cont . person = person ; // Call coroutine cont . state = updatePerson_State . Step2 ; personRepository . save ( id , person , cont ); // Done. return ; block2 : // Restore local variables Person person = cont . person ; // Handle the previous result timestamp = ( long ) result ; System . out . println ( \"Updated at: \" + timestamp ); However, at the end of the last block, we call the original continuation that we were provided with. Of course, we store the state first. // Store local variables cont . timestamp = timestamp ; // Call continuation cont . onComplete . accept ( timestamp ); // Done. return ; } Coroutines returning void A coroutine that returns no value ( void ) can be implemented by having it pass null to the continuation (of type Void ). Non-suspending Computations \u00b6 When the coroutine doesn't suspend, it can simply continue its computation. However, if we model this using continuations, for example in a loop, then we might overflow the stack. Instead, it would be better for both stack usage and performance if we could simply skip calling the continuation whenever execution is sequential. One of three things can happen in a coroutine that calls another coroutine: its continuation gets called immediately, its continuation gets called at some later point, or its continuation gets never called. In all cases does the above implementation simply return. Since we are sure a continuation is executed either once or never, we can optimize for the case where the coroutine immediately calls the continuation once. We can have the coroutine just return the result and continue normal execution. However, we then also need a way to distinguish this case from the situation where the coroutine doesn't call the continuation, so we can exit early. While we could adopt null to represent this case, null can also be a valid return value. Therefore, in Kotlin, they represent this by returning the special COROUTINE_SUSPENDED constant. The new code becomes: Object updatePerson ( int id , String name , Consumer < Object > onCompletion ) { // Get the state machine updatePerson_StateMachine cont ; if ( onCompletion instanceof updatePerson_StateMachine ) { // Resumed from a previous call cont = ( updatePerson_StateMachine ) onCompletion ; } else { // Called for the first time cont = new updatePerson_StateMachine ( onCompletion ); // Store the arguments cont . $this = this ; cont . id = id ; cont . name = name ; } Person person ; long timestamp ; Object result = cont . result ; // Decide where to resume if ( cont . state == Start ) goto block0 ; if ( cont . state == Step1 ) goto block1 ; if ( cont . state == Step2 ) goto block2 ; throw new IllegalStateException (); block0: // Restore local variables person = cont . person ; timestamp = cont . timestamp ; System . out . println ( \"Updating person with ID: \" + id ); // Call coroutine cont . state = updatePerson_State . Step1 ; result = personRepository . get ( id , cont ); // coroutine if ( result == COROUTINE_SUSPENDED ) return COROUTINE_SUSPENDED ; // Fall through block1 : // Handle the previous result person = ( Person ) result ; person . name = name ; // Store local variables cont . person = person ; // Call coroutine cont . state = updatePerson_State . Step2 ; result = personRepository . save ( id , person , cont ); if ( result == COROUTINE_SUSPENDED ) return COROUTINE_SUSPENDED ; // Fall through block2 : // Restore local variables Person person = cont . person ; // Handle the previous result timestamp = ( long ) result ; System . out . println ( \"Updated at: \" + timestamp ); // Store local variables cont . timestamp = timestamp ; // Done. return timestamp ; } Note that the state machine didn't change. class updatePerson_StateMachine implements Consumer < Object > { // Arguments Test $this ; int id ; String name ; // Local variables Person person ; long timestamp ; // State Machine updatePerson_State state ; Consumer < Object > onCompletion ; Object result ; updatePerson_StateMachine ( Consumer < Object > onCompletion ) { this . onCompletion = onCompletion ; } @Override public void accept ( Object result ) { this . result = result ; $this . updatePerson ( id , name , this ); } } enum updatePerson_State { Start , Step2 , Step3 , Done , } Handling Exceptions \u00b6 There is also the issue of handling exceptions. Whenever an exception occurs, there are two possibilities: the code was executing sequentially, and the exception can just propagate up the stack; or the exception should be passed to the continuation. To allow for this, we make the continuation not just accept any value T , but a Result<T> , which is either a value of T or an exception. class Result < T > { static < T > Result < T > success ( T value ); static < T > Result < T > failure ( Throwable exception ); boolean isSuccess (); boolean isFailure (); @Nullable T getOrNull (); @Nullable Throwable exceptionOrNull (); } The signature for the continuation changes from Function<Object, Object> to Function<Result<T>, Object> . To model this even better, we introduce a Continuation interface: interface Continuation < T > extends Consumer < Result < T >> { void resumeWith ( Result < T > result ); @Override default void accept ( Result < T > result ) { resumeWith ( result ); } // Convenience methods: default void resume ( T value ) { resumeWith ( Result . success ( value )); } default void resumeWithException ( Throwable exception ) { resumeWith ( Result . failure ( exception )); } } The basic implementation of Continuation<T> stores another continuation and calls it with the returned result. abstract class ContinuationImpl < T > implements Continuation < T > { private final Consumer < Result < T >> continuation ; public ContinuationImpl ( Consumer < Result < T >> continuation ) { this . continuation = continuation ; } @Override void resumeWith ( Result < T > result ) { Result < T > newResult ; try { T outcome = invokeSuspend ( result ); if ( outcome == COROUTINE_SUSPENDED ) return ; newResult = Result . success ( outcome ); } catch ( Throwable exception ) { newResult = Result . failure ( exception ); } if ( continuation != null ) continuation . accept ( newResult ); } abstract Object invokeSuspend ( Result < T > result ); } Optimization As long as the continuation we call is an instance of ContinuationImpl , we could instead use a loop, where we invoke invokeSuspend on the new continuation and use the previous result as the new continuation argument. Of course, this forces the base class of ContinuationImpl to be Continuation<Any> . The implementation of the state machine would be: class updatePerson_StateMachine extends ContinuationImpl < Object > { // Arguments Test $this ; int id ; String name ; // Local variables Person person ; long timestamp ; // State Machine updatePerson_State state ; Consumer < Result < Object >> onCompletion ; Result < Object > result ; updatePerson_StateMachine ( Consumer < Result < Object >> onCompletion ) { this . onCompletion = onCompletion ; } @Override public Object invokeSuspend ( Result < Object > result ) { this . result = result ; return $this . updatePerson ( id , name , this ); } } And a special Coroutines.throwOnFailure(Result<Any> result) will assert that the result is actually a successful value. Therefore, to handle the result of a coroutine call, it should first check whether the result is actually valid and not an exception. See Also \u00b6 KEEP \u2014 Kotlin Coroutines Jorge Castillo \u2014 Kotlin Continuations Ashish Kumar \u2014 Suspend functions under the hood Luciano Almeida \u2014 An Overview on Kotlin Coroutines Adrian Bukros \u2014 Diving deep into Kotlin Coroutines esoco GmbH \u2014 Coroutines in pure Java COROUTINE_SUSPENDED and suspendCoroutineOrReturn in Kotlin Suspending functions, coroutines and state machines","title":"Coroutines"},{"location":"coroutines/#coroutines","text":"Continuations that are used to implement cooperative scheduling are called coroutines . The trick to performing lazy (and possibly asynchronous) computation in Java is to explicitly encode the control flow. Instead of letting a function simply run to its end and return, we rewrite the method to use continuation passing style and provide it with a continuation that handles the result. This way, we can pause execution any time we want, and call the continuation as soon as we want to continue (as the name implies). Imagine a function updatePerson , which loads a person's record using its ID, updates its name, and saves the record again. The function returns the timestamp of when the record was saved. long updatePerson ( int id , String name ) { System . out . println ( \"Updating person with ID: \" + id ); Person person = personRepository . get ( id ); person . name = name ; long timestamp = personRepository . save ( id , person ); System . out . println ( \"Updated at: \" + timestamp ); return timestamp ; } We would call this function like this: long result = updatePerson ( 10 , \"Aya\" ); Now we want to rewrite updatePerson as a coroutine, i.e. a computation that can be suspended. We do this using continuation-passing style (CPS). We explicitly provide a continuation that the function should call to continue execution. The continuation represents the rest of the computation to be performed once this computation is done. So we change the signature to accept the continuation as the last parameter. Also, the function should no longer return its result though return , but instead by calling the continuation. void updatePerson ( int id , String name , Consumer < Long > onCompletion ) { System . out . println ( \"Updating person with ID: \" + id ); Person person = personRepository . get ( id ); person . name = name ; long timestamp = personRepository . save ( id , person ); System . out . println ( \"Updated at: \" + timestamp ); onCompletion . accept ( timestamp ); } We can call this modified updatePerson function by providing the continuation: long result ; updatePerson ( 10 , \"Daniel\" , r -> { result = r ; }); Of course, this coroutine is not very lazy yet. It can call other coroutines, so let's assume that the methods on the personRepository are also coroutines. Therefore, we need to provide them with continuations. We will tackle this next.","title":"Coroutines"},{"location":"coroutines/#cps","text":"If personRepository.get() and personRepository.save() are coroutines, we need to provide them with a continuation that they can call. We can do this by splitting our function up into separate function steps like this: void updatePerson ( int id , String name , Consumer < Long > onCompletion ) { // Start System . out . println ( \"Updating person with ID: \" + id ); personRepository . get ( id , ( result ) -> updatePerson2 ( id , name , onCompletion , result ) ); } void updatePerson2 ( int id , String name , Consumer < Long > onCompletion , Person result ){ // Step 2 Person person = result ; person . name = name ; personRepository . save ( id , person , ( result ) -> updatePerson3 ( id , name , person , onCompletion , result ) ); } void updatePerson3 ( int id , String name , Person person , Consumer < Long > onCompletion , long result ){ // Step 3 long timestamp = result ; System . out . println ( \"Updated at: \" + timestamp ); onCompletion . accept ( timestamp ); } Note that the coroutine is called as the last action in each function step. This means that they can take advantage of tail call optimization to avoid creating a new stack frame for each coroutine or continuation call. But tail call optimization has its own downsides: it will appear as if the calls in between never happened, which makes debugging, stack tracing, and access control more difficult. Also note that the above example creates a new closure for every continuation, and finally but most importantly, Java does not support tail call optimization at all.","title":"CPS"},{"location":"coroutines/#state-machine","text":"Let's see if we can solve some of these problems. Firstly, let's reduce the number of objects that are needed for representing continuations, because if we were to execute a coroutine in a loop, we would end up with a lot of continuation closure objects. One way to solve this is to create a state machine, which takes the place of each of the continuations. To call the correct function step, we need to track which step we expect to execute next. Additionally, to provide the arguments and local variables to the call, we store them in the state machine. class updatePerson_StateMachine implements Consumer < Object > { // Arguments Test $this ; int id ; String name ; // Local variables Person person ; long timestamp ; // State Machine updatePerson_State state ; Function < Object , Object > onCompletion ; updatePerson_StateMachine ( Function < Object , Object > onCompletion ) { this . onCompletion = onCompletion ; } @Override public void accept ( Object result ) { switch ( state ) { case Start : throw new IllegalStateException (); case Step2 : $this . updatePerson2 ( id , name , this , result ); break ; case Step3 : $this . updatePerson3 ( id , name , person , this , result ); break ; default : throw new IllegalStateException (); } } } enum updatePerson_State { Start , Step2 , Step3 , Done , } The state machine class is relatively straightforward. Being a state machine, it has to store the current state in its state field. The state determines at which function step will resume when the state machine is used as a continuation. Because we reuse the state machine object, it will get return values of different types after each suspending function. Therefore, it has type Consumer<Object> , accepting any object (including null ). It would be used as a continuation like this: void updatePerson ( int id , String name , Consumer < Long > onCompletion ) { // Start // Create state machine updatePerson_StateMachine cont = new updatePerson_StateMachine ( onCompletion ); System . out . println ( \"Updating person with ID: \" + id ); // Store arguments cont . id = id ; cont . name = name ; // Call coroutine cont . state = updatePerson_State . Step2 ; personRepository . get ( id , cont ); } void updatePerson2 ( int id , String name , updatePerson_StateMachine cont , Person result ){ // Step 2 Person person = result ; person . name = name ; // Store local variables cont . person = person ; // Call coroutine cont . state = updatePerson_State . Step3 ; personRepository . save ( id , person , cont ); } void updatePerson3 ( int id , String name , Person person , updatePerson_StateMachine cont , long result ){ // Step 3 long timestamp = result ; System . out . println ( \"Updated at: \" + timestamp ); cont . onCompletion . accept ( timestamp ); } Here we make the implicit assumption that the state machine continuation is only called zero or one time. If the same continuation would be called more than once, then the stored local variables and next state might go wrong.","title":"State Machine"},{"location":"coroutines/#single-function","text":"Our coroutine is still split across functions, which makes it harder to debug and stack trace. We can improve this by putting the different function steps back into one function, and using the state machine's state to jump to the correct piece of code. The function needs to determine whether it is being called for the first time (using some other continuation), or being resumed (using the state machine as the continuation). If it is being resumed, it will be given the state machine as its continuation. Otherwise, if this is the first call, it will be given another continuation, and we should instantiate a new state machine and store the arguments and continuation in it. void updatePerson ( int id , String name , Consumer < Object > onCompletion ) { // Get the state machine updatePerson_StateMachine cont ; if ( onCompletion instanceof updatePerson_StateMachine ) { // Resumed from a previous call cont = ( updatePerson_StateMachine ) onCompletion ; } else { // Called for the first time cont = new updatePerson_StateMachine ( onCompletion ); // Store the arguments cont . $this = this ; cont . id = id ; cont . name = name ; } Recursive calls How do we distinguish a direct recursive call to the coroutine (providing the state machine of the parent call as the continuation) from a resumed call (providing the state machine of this call as the continuation)? The next step is to decide where to resume to. If we somehow ended up in an illegal state, we throw an exception. Person person ; long timestamp ; Object result = cont . result ; // Decide where to resume if ( cont . state == Start ) goto block0 ; if ( cont . state == Step1 ) goto block1 ; if ( cont . state == Step2 ) goto block2 ; throw new IllegalStateException (); Each resumption point has to start with restoring the local variables from the saved state. block0 : // Restore local variables person = cont . person ; timestamp = cont . timestamp ; The next code is just the sequential code in between two coroutines. Since we reinstated the arguments and restored local variables, this should be straightforward. System . out . println ( \"Updating person with ID: \" + id ); Now we end the block with a call to another coroutine. Just before the call we should store the changed local variables (if any), and update the state field to get us to the next step once the continuation is called. // Call coroutine cont . state = updatePerson_State . Step1 ; personRepository . get ( id , cont ); // coroutine We can exit this function now. Execution will resume from the next block when the continuation is called. // Done. return ; Upon entering the next step, it should restore the local variables (if any) and handle the result provided to the continuation, the result returned by the coroutine that was called previously. Note that since the result is not provided explicitly as an argument to the function, we store it in the state machine continuation instead. block1 : // Handle the previous result person = ( Person ) result ; This is also where we would assign it to a variable. Note that the initial step is not expecting any results yet (because we didn't end up here through calling a coroutine), but later steps do. The rest of the code is straightforward: person . name = name ; // Store local variables cont . person = person ; // Call coroutine cont . state = updatePerson_State . Step2 ; personRepository . save ( id , person , cont ); // Done. return ; block2 : // Restore local variables Person person = cont . person ; // Handle the previous result timestamp = ( long ) result ; System . out . println ( \"Updated at: \" + timestamp ); However, at the end of the last block, we call the original continuation that we were provided with. Of course, we store the state first. // Store local variables cont . timestamp = timestamp ; // Call continuation cont . onComplete . accept ( timestamp ); // Done. return ; } Coroutines returning void A coroutine that returns no value ( void ) can be implemented by having it pass null to the continuation (of type Void ).","title":"Single Function"},{"location":"coroutines/#non-suspending-computations","text":"When the coroutine doesn't suspend, it can simply continue its computation. However, if we model this using continuations, for example in a loop, then we might overflow the stack. Instead, it would be better for both stack usage and performance if we could simply skip calling the continuation whenever execution is sequential. One of three things can happen in a coroutine that calls another coroutine: its continuation gets called immediately, its continuation gets called at some later point, or its continuation gets never called. In all cases does the above implementation simply return. Since we are sure a continuation is executed either once or never, we can optimize for the case where the coroutine immediately calls the continuation once. We can have the coroutine just return the result and continue normal execution. However, we then also need a way to distinguish this case from the situation where the coroutine doesn't call the continuation, so we can exit early. While we could adopt null to represent this case, null can also be a valid return value. Therefore, in Kotlin, they represent this by returning the special COROUTINE_SUSPENDED constant. The new code becomes: Object updatePerson ( int id , String name , Consumer < Object > onCompletion ) { // Get the state machine updatePerson_StateMachine cont ; if ( onCompletion instanceof updatePerson_StateMachine ) { // Resumed from a previous call cont = ( updatePerson_StateMachine ) onCompletion ; } else { // Called for the first time cont = new updatePerson_StateMachine ( onCompletion ); // Store the arguments cont . $this = this ; cont . id = id ; cont . name = name ; } Person person ; long timestamp ; Object result = cont . result ; // Decide where to resume if ( cont . state == Start ) goto block0 ; if ( cont . state == Step1 ) goto block1 ; if ( cont . state == Step2 ) goto block2 ; throw new IllegalStateException (); block0: // Restore local variables person = cont . person ; timestamp = cont . timestamp ; System . out . println ( \"Updating person with ID: \" + id ); // Call coroutine cont . state = updatePerson_State . Step1 ; result = personRepository . get ( id , cont ); // coroutine if ( result == COROUTINE_SUSPENDED ) return COROUTINE_SUSPENDED ; // Fall through block1 : // Handle the previous result person = ( Person ) result ; person . name = name ; // Store local variables cont . person = person ; // Call coroutine cont . state = updatePerson_State . Step2 ; result = personRepository . save ( id , person , cont ); if ( result == COROUTINE_SUSPENDED ) return COROUTINE_SUSPENDED ; // Fall through block2 : // Restore local variables Person person = cont . person ; // Handle the previous result timestamp = ( long ) result ; System . out . println ( \"Updated at: \" + timestamp ); // Store local variables cont . timestamp = timestamp ; // Done. return timestamp ; } Note that the state machine didn't change. class updatePerson_StateMachine implements Consumer < Object > { // Arguments Test $this ; int id ; String name ; // Local variables Person person ; long timestamp ; // State Machine updatePerson_State state ; Consumer < Object > onCompletion ; Object result ; updatePerson_StateMachine ( Consumer < Object > onCompletion ) { this . onCompletion = onCompletion ; } @Override public void accept ( Object result ) { this . result = result ; $this . updatePerson ( id , name , this ); } } enum updatePerson_State { Start , Step2 , Step3 , Done , }","title":"Non-suspending Computations"},{"location":"coroutines/#handling-exceptions","text":"There is also the issue of handling exceptions. Whenever an exception occurs, there are two possibilities: the code was executing sequentially, and the exception can just propagate up the stack; or the exception should be passed to the continuation. To allow for this, we make the continuation not just accept any value T , but a Result<T> , which is either a value of T or an exception. class Result < T > { static < T > Result < T > success ( T value ); static < T > Result < T > failure ( Throwable exception ); boolean isSuccess (); boolean isFailure (); @Nullable T getOrNull (); @Nullable Throwable exceptionOrNull (); } The signature for the continuation changes from Function<Object, Object> to Function<Result<T>, Object> . To model this even better, we introduce a Continuation interface: interface Continuation < T > extends Consumer < Result < T >> { void resumeWith ( Result < T > result ); @Override default void accept ( Result < T > result ) { resumeWith ( result ); } // Convenience methods: default void resume ( T value ) { resumeWith ( Result . success ( value )); } default void resumeWithException ( Throwable exception ) { resumeWith ( Result . failure ( exception )); } } The basic implementation of Continuation<T> stores another continuation and calls it with the returned result. abstract class ContinuationImpl < T > implements Continuation < T > { private final Consumer < Result < T >> continuation ; public ContinuationImpl ( Consumer < Result < T >> continuation ) { this . continuation = continuation ; } @Override void resumeWith ( Result < T > result ) { Result < T > newResult ; try { T outcome = invokeSuspend ( result ); if ( outcome == COROUTINE_SUSPENDED ) return ; newResult = Result . success ( outcome ); } catch ( Throwable exception ) { newResult = Result . failure ( exception ); } if ( continuation != null ) continuation . accept ( newResult ); } abstract Object invokeSuspend ( Result < T > result ); } Optimization As long as the continuation we call is an instance of ContinuationImpl , we could instead use a loop, where we invoke invokeSuspend on the new continuation and use the previous result as the new continuation argument. Of course, this forces the base class of ContinuationImpl to be Continuation<Any> . The implementation of the state machine would be: class updatePerson_StateMachine extends ContinuationImpl < Object > { // Arguments Test $this ; int id ; String name ; // Local variables Person person ; long timestamp ; // State Machine updatePerson_State state ; Consumer < Result < Object >> onCompletion ; Result < Object > result ; updatePerson_StateMachine ( Consumer < Result < Object >> onCompletion ) { this . onCompletion = onCompletion ; } @Override public Object invokeSuspend ( Result < Object > result ) { this . result = result ; return $this . updatePerson ( id , name , this ); } } And a special Coroutines.throwOnFailure(Result<Any> result) will assert that the result is actually a successful value. Therefore, to handle the result of a coroutine call, it should first check whether the result is actually valid and not an exception.","title":"Handling Exceptions"},{"location":"coroutines/#see-also","text":"KEEP \u2014 Kotlin Coroutines Jorge Castillo \u2014 Kotlin Continuations Ashish Kumar \u2014 Suspend functions under the hood Luciano Almeida \u2014 An Overview on Kotlin Coroutines Adrian Bukros \u2014 Diving deep into Kotlin Coroutines esoco GmbH \u2014 Coroutines in pure Java COROUTINE_SUSPENDED and suspendCoroutineOrReturn in Kotlin Suspending functions, coroutines and state machines","title":"See Also"},{"location":"delimited-continuations/","text":"Delimited Continuations \u00b6 To model yield and lazy sequences, we need delimited continuations. The call/cc control operator captures the rest of the whole program, which is an example of an undelimited continuation . However, delimited continuation only capture a slice of the program, and allow us to return a value. See Also \u00b6 Fischer \u2013 Laymans explanation of delimited continuations Andy Wingo \u2014 Guile and Delimited Continuations","title":"Delimited Continuations"},{"location":"delimited-continuations/#delimited-continuations","text":"To model yield and lazy sequences, we need delimited continuations. The call/cc control operator captures the rest of the whole program, which is an example of an undelimited continuation . However, delimited continuation only capture a slice of the program, and allow us to return a value.","title":"Delimited Continuations"},{"location":"delimited-continuations/#see-also","text":"Fischer \u2013 Laymans explanation of delimited continuations Andy Wingo \u2014 Guile and Delimited Continuations","title":"See Also"},{"location":"generators/","text":"Generators \u00b6 A generator yields values one at a time, allowing the calling code to process them as soon as they become available. Generators ae semicoroutines .","title":"Generators"},{"location":"generators/#generators","text":"A generator yields values one at a time, allowing the calling code to process them as soon as they become available. Generators ae semicoroutines .","title":"Generators"},{"location":"java-interop/","text":"Java Interop \u00b6 Static Functions and Variables \u00b6 Static Java members like these: package java.util ; class Collections { public static < T > List < T > emptyList (); public static < T > Set < T > emptySet (); } class Arrays { public static < T > List < T > asList ( T ... a ); } package java.lang ; class Integer { public static final int MIN_VALUE = 0x80000000 ; public static final int MAX_VALUE = 0x7fffffff ; public static int parseInt ( String s ); public static int parseInt ( String s , int radix ); public static String toString ( Integer i ); public static String toString ( Integer i , int radix ); } Are declared in Tego as: module java.util extern fun Collections.emptyList<T>(): Unit -> List<T> extern fun Collections.emptySet<T>(): Unit -> Set<T> extern fun Arrays.asList<T>(a: Array<T>): Unit -> List<T> module java.lang extern const Integer.MIN_VALUE: Int extern const Integer.MAX_VALUE: Int extern fun Integer.parseInt(s: String): Unit -> Int extern fun Integer.parseInt(s: String, radix: Int): Unit -> Int extern fun Integer.toString(i: Int): Unit -> String extern fun Integer.toString(i: Int, radix: Int): Unit -> String Note the difference between the name Integer.toString and the receiver type (for static members this is always Unit ). And have the types: <T> Unit -> List<T> // emptyList <T> Unit -> Set<T> // emptySet <T> (Array<T>) Unit -> List<T> // asList Int // MIN_VALUE Int // MAX_VALUE (String) Unit -> Int // parseInt (String, Int) Unit -> Int // parseInt (Int) Unit -> String // toString (Int, Int) Unit -> String // toString Static functions with no arguments Since there is no type to represent a function with no receiver (i.e., static), its implicit input is of type Unit . Instance Functions and Variables \u00b6 Instance Java members like these: package java.lang ; class Object { public int hashCode (); public boolean equals ( Object obj ); public String toString (); } class Pair < T1 , T2 > { public T1 c1 ; public T2 c2 ; } Are declared in Tego as: module java.lang extern class Object extern fun Object.hashCode(): Object -> Int extern fun Object.equals(obj: Object): Object -> Bool extern fun Object.toString(): Object -> String extern class Pair<T1, T2> extern fun Pair<T1, T2>.c1: Pair<T1, T2> -> T1 // getter extern fun Pair<T1, T2>.c1(value: T1): Pair<T1, T2> -> T1 // setter extern fun Pair<T1, T2>.c2: Pair<T1, T2> -> T2 // getter extern fun Pair<T1, T2>.c2(value: T2): Pair<T1, T2> -> T2 // getter And have the types: Class<Object> // class Object Object -> Int // hashCode (Object) Object -> Bool // equals Object -> String // toString Class<Pair> // class Pair<T1, T2> Pair<T1, T2> -> T1 // c1 (getter) (T1) Pair<T1, T2> -> T1 // c1 (setter) Pair<T1, T2> -> T2 // c2 (getter) (T2) Pair<T1, T2> -> T2 // c2 (setter) Build Operator \u00b6 A value can be turned into a strategy using the build-operator ! . Similarly, the build operator can turn a strategy that takes Unit into a value. internal fun build<T>(v: T): Any -> T Any strategy can be applied to its input value using the angled brackets operator: <s> v // s: A -> B; v: A, : Any -> B Which is syntactic sugar for: !v; s // s: A -> B; v: A, !v : Any -> A, : Any -> B A static function with no arguments (or none applied) can be called using the build operator ! . // With explicit number of arguments fun emptyList(): List<Int> = !Collections.emptyList() // Function fun emptySet(): Any -> Set<Int> = !Collections.emptySet Static Functions with One Argument \u00b6 The static function must implicitly take the implicit argument as the first (and only) argument. fun dec2int(s: String): Int = !s; Integer.parseInt fun int2dec(i: Int): String = !i; Integer.toString Overloading When multiple functions with the same signature exist, from all functions with a compatible signature, the shortest one is selected. To specify explicitly how many arguments the function has, you can use the special .. argument. For example: fun dec2int(s: String): Int = !s; Integer.parseInt() // Explicitly the overload with no other parameters fun 2int(s: String): Int -> Int = !s; Integer.parseInt(..) // Partial application // ...providing the first argument, //selecting the overload with two arguments Static Functions with Multiple Arguments \u00b6 The static function must implicitly take the implicit argument as the first argument. The other arguments can be provided through application. fun hex2int(s: String): Int = !s; Integer.parseInt(16) fun int2hex(i: Int): String = !s; Integer.toString(16)","title":"Java Interop"},{"location":"java-interop/#java-interop","text":"","title":"Java Interop"},{"location":"java-interop/#static-functions-and-variables","text":"Static Java members like these: package java.util ; class Collections { public static < T > List < T > emptyList (); public static < T > Set < T > emptySet (); } class Arrays { public static < T > List < T > asList ( T ... a ); } package java.lang ; class Integer { public static final int MIN_VALUE = 0x80000000 ; public static final int MAX_VALUE = 0x7fffffff ; public static int parseInt ( String s ); public static int parseInt ( String s , int radix ); public static String toString ( Integer i ); public static String toString ( Integer i , int radix ); } Are declared in Tego as: module java.util extern fun Collections.emptyList<T>(): Unit -> List<T> extern fun Collections.emptySet<T>(): Unit -> Set<T> extern fun Arrays.asList<T>(a: Array<T>): Unit -> List<T> module java.lang extern const Integer.MIN_VALUE: Int extern const Integer.MAX_VALUE: Int extern fun Integer.parseInt(s: String): Unit -> Int extern fun Integer.parseInt(s: String, radix: Int): Unit -> Int extern fun Integer.toString(i: Int): Unit -> String extern fun Integer.toString(i: Int, radix: Int): Unit -> String Note the difference between the name Integer.toString and the receiver type (for static members this is always Unit ). And have the types: <T> Unit -> List<T> // emptyList <T> Unit -> Set<T> // emptySet <T> (Array<T>) Unit -> List<T> // asList Int // MIN_VALUE Int // MAX_VALUE (String) Unit -> Int // parseInt (String, Int) Unit -> Int // parseInt (Int) Unit -> String // toString (Int, Int) Unit -> String // toString Static functions with no arguments Since there is no type to represent a function with no receiver (i.e., static), its implicit input is of type Unit .","title":"Static Functions and Variables"},{"location":"java-interop/#instance-functions-and-variables","text":"Instance Java members like these: package java.lang ; class Object { public int hashCode (); public boolean equals ( Object obj ); public String toString (); } class Pair < T1 , T2 > { public T1 c1 ; public T2 c2 ; } Are declared in Tego as: module java.lang extern class Object extern fun Object.hashCode(): Object -> Int extern fun Object.equals(obj: Object): Object -> Bool extern fun Object.toString(): Object -> String extern class Pair<T1, T2> extern fun Pair<T1, T2>.c1: Pair<T1, T2> -> T1 // getter extern fun Pair<T1, T2>.c1(value: T1): Pair<T1, T2> -> T1 // setter extern fun Pair<T1, T2>.c2: Pair<T1, T2> -> T2 // getter extern fun Pair<T1, T2>.c2(value: T2): Pair<T1, T2> -> T2 // getter And have the types: Class<Object> // class Object Object -> Int // hashCode (Object) Object -> Bool // equals Object -> String // toString Class<Pair> // class Pair<T1, T2> Pair<T1, T2> -> T1 // c1 (getter) (T1) Pair<T1, T2> -> T1 // c1 (setter) Pair<T1, T2> -> T2 // c2 (getter) (T2) Pair<T1, T2> -> T2 // c2 (setter)","title":"Instance Functions and Variables"},{"location":"java-interop/#build-operator","text":"A value can be turned into a strategy using the build-operator ! . Similarly, the build operator can turn a strategy that takes Unit into a value. internal fun build<T>(v: T): Any -> T Any strategy can be applied to its input value using the angled brackets operator: <s> v // s: A -> B; v: A, : Any -> B Which is syntactic sugar for: !v; s // s: A -> B; v: A, !v : Any -> A, : Any -> B A static function with no arguments (or none applied) can be called using the build operator ! . // With explicit number of arguments fun emptyList(): List<Int> = !Collections.emptyList() // Function fun emptySet(): Any -> Set<Int> = !Collections.emptySet","title":"Build Operator"},{"location":"java-interop/#static-functions-with-one-argument","text":"The static function must implicitly take the implicit argument as the first (and only) argument. fun dec2int(s: String): Int = !s; Integer.parseInt fun int2dec(i: Int): String = !i; Integer.toString Overloading When multiple functions with the same signature exist, from all functions with a compatible signature, the shortest one is selected. To specify explicitly how many arguments the function has, you can use the special .. argument. For example: fun dec2int(s: String): Int = !s; Integer.parseInt() // Explicitly the overload with no other parameters fun 2int(s: String): Int -> Int = !s; Integer.parseInt(..) // Partial application // ...providing the first argument, //selecting the overload with two arguments","title":"Static Functions with One Argument"},{"location":"java-interop/#static-functions-with-multiple-arguments","text":"The static function must implicitly take the implicit argument as the first argument. The other arguments can be provided through application. fun hex2int(s: String): Int = !s; Integer.parseInt(16) fun int2hex(i: Int): String = !s; Integer.toString(16)","title":"Static Functions with Multiple Arguments"},{"location":"modifiers/","text":"Modifiers \u00b6 Declaration Modifiers \u00b6 A declaration can be marked with one or more of the following modifiers (but note that not all combinations are valid): public \u2014 The declaration is public, visible from outside the module. (Otherwise: private, visible only in the module.) extern \u2014 The declaration has a definition which is provided externally. (Otherwise: declaration must be provided in the module.) Module Modifiers \u00b6 A module can be marked with one or more of the following modifiers (but note that not all combinations are valid): extern \u2014 The declarations in the module are public by default and provided externally. (Otherwise: declarations are private by default.)","title":"Modifiers"},{"location":"modifiers/#modifiers","text":"","title":"Modifiers"},{"location":"modifiers/#declaration-modifiers","text":"A declaration can be marked with one or more of the following modifiers (but note that not all combinations are valid): public \u2014 The declaration is public, visible from outside the module. (Otherwise: private, visible only in the module.) extern \u2014 The declaration has a definition which is provided externally. (Otherwise: declaration must be provided in the module.)","title":"Declaration Modifiers"},{"location":"modifiers/#module-modifiers","text":"A module can be marked with one or more of the following modifiers (but note that not all combinations are valid): extern \u2014 The declarations in the module are public by default and provided externally. (Otherwise: declarations are private by default.)","title":"Module Modifiers"},{"location":"sequences/","text":"Sequences \u00b6 A sequence is a computation that lazily produces values. For example, the following computation prints the first ten even fibonacci numbers: static void Main ( String [] args ) { // Build the computation Iterable < Integer > tenEvenFibonacciNumbers = Take ( 10 , EvenNumbersOnly ( Fibonacci ())); // Print the results for ( Integer e : tenEvenFibonacciNumbers ) { System . out . println ( e ); } } static Iterable < Integer > Fibonacci () { return buildSequence ( b -> { b . yield ( 1 ); // First fibonacci numnber int currFib = 1 ; int nextFib = 1 ; while ( true ) { b . yield ( nextFib ); int newFib = currFib + nextFib ; currFib = nextFib ; nextFib = newFib ; } }); } static Iterable < Integer > EvenNumbersOnly ( Iterable < Integer > sequence ) { return buildSequence ( b -> { for ( Integer i : sequence ) { if (( i % 2 ) == 0 ) { b . yield ( i ); } } }); } static < T > Iterable < T > Take ( int limit , Iterable < T > sequence ) { return buildSequence ( b -> { int count = 0 ; for ( T e : sequence ) { if ( count >= limit ) return ; b . yield ( e ); count += 1 ; } }); } This pseudo-Java code illustrates how we would like to write a lazy computation as imperative code. The buildSequence() takes an imperatively written piece of code and turns it into a lazy computation, returning an Iterable<T> . The lambda argument to the buildSequence() method takes a computation builder b , which has a method yield() which will suspend the computation and yield the value. Note that in current Java there is no way to implement buildSequence() or yield() to make this Java code work as intended. However, we will use this to illustrate how we can transform such code into Java code that is executable, and performs the intended lazy computation. State Machine \u00b6 We can represent each computation using a dedicated state machine. The Fibonacci function would be implemented as: static Iterable < Integer > Fibonacci () { return new Iterable < Integer > () { @NotNull @Override public Iterator < Integer > iterator () { return new Iterator < Integer > () { private Fibonacci_State _state = Fibonacci_State . Start ; private boolean _hasCurrent = false ; private Integer _current ; private int currFib ; private int nextFib ; @Override public boolean hasNext () { if ( _state == Fibonacci_State . Start ) { // Compute the first element computeNext (); } return _hasCurrent ; } @Override public Integer next () { if ( ! _hasCurrent && _state != Fibonacci_State . Done ) { // Compute the next element computeNext (); } _hasCurrent = false ; return _current ; } private void computeNext () { if ( _state == Fibonacci_State . Start ) goto start ; if ( _state == Fibonacci_State . Step2 ) goto step2 ; if ( _state == Fibonacci_State . Step3 ) goto step3 ; throw new IllegalStateException (); start: _current = 1 ; _hasCurrent = true ; _state = Fibonacci_State . Step2 ; return ; step2 : currFib = 1 ; nextFib = 1 ; // Fall through loopstart : _current = nextFib ; _hasCurrent = true ; _state = Fibonacci_State . Step3 ; return ; step3 : int newFib = currFib + nextFib ; currFib = nextFib ; nextFib = newFib ; // Goto loopStart _state = Fibonacci_State . LoopStart ; goto loopstart ; done : return ; } }; } }; } enum Fibonacci_State { Start , Step2 , Step3 , Done , } Note that we modeled the control flow using goto statements, which don't exist in Java but do illustrate the transformation to a statemachine more clearly. Also note how the loop, which is a goto statement in byte code, is still present in the code in the form of the loopstart label; dealing with loops requires no special machinery. The yield(e) calls have been transformed into the sequence: _current = e ; _hasCurrent = true ; _state = next_state ; Where next_state is the next state where the state machine should resume. Optimizations \u00b6 We can optimize this a bit by not creating an enum but just using integer values for the states. Also, we can reduce the number of local variables we need to store in the iterator by doing some use-def analysis. If they don't cross block bounaries, they do not need to be in the iterator state. ANF \u00b6 Functional Fibonacci sequence in Tego: decl fibs : [Int] fibs = [0 | 1 | <zipWith(add)> (fibs, <tail> fibs)] In ANF: yield 0 yield 1 let zwa = zipWith(add) in let tl = <tail> fibs in let tup = (fibs, tl) in let l = <zwa> tup in yieldAll l Evaluation vs Application A strategy s evaluated with value v as input, is written as <s> v . A strategy s applied to arguments a1 , a2 , .., an is writen as s(a1, a2, .., an) . Therefore, to apply and evaluate a strategy in one go, is to write <s(a1, a2, .., an)> v . Yielding The yield construct yields a value for a lazy sequence. Note that yieldAll is actually just a loop and a yield, so we get: yield 0 yield 1 let zwa = zipWith(add) in let tl = <tail> fibs in let tup = (fibs, tl) in let l = <zwa> tup in let iter = <Iterable.getIterator> l in let hn = <Iterator.hasNext> iter in while (hn) { let n = <Iterator.next> iter in yield n hn = <Iterator.hasNext> iter } Writing the ANF out in a state machine, we get: let state = getState() in let s0 = (state == 0) in if (s0) { // yield 0 setState(1) setCurrent(0) } else { let s1 = (state == 1) in if (s1) { // yield 1 setState(2) setCurrent(1) } else { let s2 = (state == 2) in if (s2) { let zwa = zipWith(add) in let tl = <tail> fibs in let tup = (fibs, tl) in let l = <zwa> tup in } else { } } } return new Iterator<Integer>() { private Fibonacci_State _state = Fibonacci_State.Start; private boolean _hasCurrent = false; private Integer _current; private int currFib; private int nextFib; @Override public boolean hasNext() { if (_state == Fibonacci_State.Start) { // Compute the first element computeNext(); } return _hasCurrent; } @Override public Integer next() { if (!_hasCurrent && _state != Fibonacci_State.Done) { // Compute the next element computeNext(); } _hasCurrent = false; return _current; } private void computeNext() { if (_state == Fibonacci_State.Start) goto start; if (_state == Fibonacci_State.Step2) goto step2; if (_state == Fibonacci_State.Step3) goto step3; throw new IllegalStateException(); start: _current = 1; _hasCurrent = true; _state = Fibonacci_State.Step2; return; step2: currFib = 1; nextFib = 1; // Fall through loopstart: _current = nextFib; _hasCurrent = true; _state = Fibonacci_State.Step3; return; step3: int newFib = currFib + nextFib; currFib = nextFib; nextFib = newFib; // Goto loopStart _state = Fibonacci_State.LoopStart; goto loopstart; done: return; } };","title":"Sequences"},{"location":"sequences/#sequences","text":"A sequence is a computation that lazily produces values. For example, the following computation prints the first ten even fibonacci numbers: static void Main ( String [] args ) { // Build the computation Iterable < Integer > tenEvenFibonacciNumbers = Take ( 10 , EvenNumbersOnly ( Fibonacci ())); // Print the results for ( Integer e : tenEvenFibonacciNumbers ) { System . out . println ( e ); } } static Iterable < Integer > Fibonacci () { return buildSequence ( b -> { b . yield ( 1 ); // First fibonacci numnber int currFib = 1 ; int nextFib = 1 ; while ( true ) { b . yield ( nextFib ); int newFib = currFib + nextFib ; currFib = nextFib ; nextFib = newFib ; } }); } static Iterable < Integer > EvenNumbersOnly ( Iterable < Integer > sequence ) { return buildSequence ( b -> { for ( Integer i : sequence ) { if (( i % 2 ) == 0 ) { b . yield ( i ); } } }); } static < T > Iterable < T > Take ( int limit , Iterable < T > sequence ) { return buildSequence ( b -> { int count = 0 ; for ( T e : sequence ) { if ( count >= limit ) return ; b . yield ( e ); count += 1 ; } }); } This pseudo-Java code illustrates how we would like to write a lazy computation as imperative code. The buildSequence() takes an imperatively written piece of code and turns it into a lazy computation, returning an Iterable<T> . The lambda argument to the buildSequence() method takes a computation builder b , which has a method yield() which will suspend the computation and yield the value. Note that in current Java there is no way to implement buildSequence() or yield() to make this Java code work as intended. However, we will use this to illustrate how we can transform such code into Java code that is executable, and performs the intended lazy computation.","title":"Sequences"},{"location":"sequences/#state-machine","text":"We can represent each computation using a dedicated state machine. The Fibonacci function would be implemented as: static Iterable < Integer > Fibonacci () { return new Iterable < Integer > () { @NotNull @Override public Iterator < Integer > iterator () { return new Iterator < Integer > () { private Fibonacci_State _state = Fibonacci_State . Start ; private boolean _hasCurrent = false ; private Integer _current ; private int currFib ; private int nextFib ; @Override public boolean hasNext () { if ( _state == Fibonacci_State . Start ) { // Compute the first element computeNext (); } return _hasCurrent ; } @Override public Integer next () { if ( ! _hasCurrent && _state != Fibonacci_State . Done ) { // Compute the next element computeNext (); } _hasCurrent = false ; return _current ; } private void computeNext () { if ( _state == Fibonacci_State . Start ) goto start ; if ( _state == Fibonacci_State . Step2 ) goto step2 ; if ( _state == Fibonacci_State . Step3 ) goto step3 ; throw new IllegalStateException (); start: _current = 1 ; _hasCurrent = true ; _state = Fibonacci_State . Step2 ; return ; step2 : currFib = 1 ; nextFib = 1 ; // Fall through loopstart : _current = nextFib ; _hasCurrent = true ; _state = Fibonacci_State . Step3 ; return ; step3 : int newFib = currFib + nextFib ; currFib = nextFib ; nextFib = newFib ; // Goto loopStart _state = Fibonacci_State . LoopStart ; goto loopstart ; done : return ; } }; } }; } enum Fibonacci_State { Start , Step2 , Step3 , Done , } Note that we modeled the control flow using goto statements, which don't exist in Java but do illustrate the transformation to a statemachine more clearly. Also note how the loop, which is a goto statement in byte code, is still present in the code in the form of the loopstart label; dealing with loops requires no special machinery. The yield(e) calls have been transformed into the sequence: _current = e ; _hasCurrent = true ; _state = next_state ; Where next_state is the next state where the state machine should resume.","title":"State Machine"},{"location":"sequences/#optimizations","text":"We can optimize this a bit by not creating an enum but just using integer values for the states. Also, we can reduce the number of local variables we need to store in the iterator by doing some use-def analysis. If they don't cross block bounaries, they do not need to be in the iterator state.","title":"Optimizations"},{"location":"sequences/#anf","text":"Functional Fibonacci sequence in Tego: decl fibs : [Int] fibs = [0 | 1 | <zipWith(add)> (fibs, <tail> fibs)] In ANF: yield 0 yield 1 let zwa = zipWith(add) in let tl = <tail> fibs in let tup = (fibs, tl) in let l = <zwa> tup in yieldAll l Evaluation vs Application A strategy s evaluated with value v as input, is written as <s> v . A strategy s applied to arguments a1 , a2 , .., an is writen as s(a1, a2, .., an) . Therefore, to apply and evaluate a strategy in one go, is to write <s(a1, a2, .., an)> v . Yielding The yield construct yields a value for a lazy sequence. Note that yieldAll is actually just a loop and a yield, so we get: yield 0 yield 1 let zwa = zipWith(add) in let tl = <tail> fibs in let tup = (fibs, tl) in let l = <zwa> tup in let iter = <Iterable.getIterator> l in let hn = <Iterator.hasNext> iter in while (hn) { let n = <Iterator.next> iter in yield n hn = <Iterator.hasNext> iter } Writing the ANF out in a state machine, we get: let state = getState() in let s0 = (state == 0) in if (s0) { // yield 0 setState(1) setCurrent(0) } else { let s1 = (state == 1) in if (s1) { // yield 1 setState(2) setCurrent(1) } else { let s2 = (state == 2) in if (s2) { let zwa = zipWith(add) in let tl = <tail> fibs in let tup = (fibs, tl) in let l = <zwa> tup in } else { } } } return new Iterator<Integer>() { private Fibonacci_State _state = Fibonacci_State.Start; private boolean _hasCurrent = false; private Integer _current; private int currFib; private int nextFib; @Override public boolean hasNext() { if (_state == Fibonacci_State.Start) { // Compute the first element computeNext(); } return _hasCurrent; } @Override public Integer next() { if (!_hasCurrent && _state != Fibonacci_State.Done) { // Compute the next element computeNext(); } _hasCurrent = false; return _current; } private void computeNext() { if (_state == Fibonacci_State.Start) goto start; if (_state == Fibonacci_State.Step2) goto step2; if (_state == Fibonacci_State.Step3) goto step3; throw new IllegalStateException(); start: _current = 1; _hasCurrent = true; _state = Fibonacci_State.Step2; return; step2: currFib = 1; nextFib = 1; // Fall through loopstart: _current = nextFib; _hasCurrent = true; _state = Fibonacci_State.Step3; return; step3: int newFib = currFib + nextFib; currFib = nextFib; nextFib = newFib; // Goto loopStart _state = Fibonacci_State.LoopStart; goto loopstart; done: return; } };","title":"ANF"},{"location":"strategies/","text":"Strategies \u00b6 A strategy producing one or more results lazily. To achieve this, they are implemented using coroutines and state machines. It may call other strategies lazily, when their results are needed. /* Let's look at the Fibonacci sequence as an example. The Tego following definition of fib returns an infinite sequence of Fibonacci numbers, starting with 0 and 1 : decl fib: Any -> [Int] fib = <generate(fib_next); fst> (0, 1). decl fib_next: (Int, Int) -> (Int, Int) fib_next n1, n2 = !(n2, <add> (n1, n2)). Its definition uses the ! operator, which is syntactic sugar for the built-in build strategy that takes a value and wraps it in a strategy. The strategy also uses the add and fst strategies, which add two integers in a tuple and project the first component of a tuple, respectively. Their signatures are: decl build<T>(T): Any -> T decl fst<T>: (T, Any) -> T decl add: (Int, Int) -> Int Finally, the strategy uses the special generate strategy, which produces an infinite sequence by applying a given strategy to the current value. It is defined as: */ Let's look at the generate strategy. This strategy takes an initial value and a strategy, and produces an infinite sequence of values. It is defined as follows: decl generate<T>(T -> T): T -> [T] generate(s) i = v := <s> i; ![v | <generate(s)> v]. Definition of generate The generate strategy is defined recursively, building the head of the sequence and recursively building the tail of the sequence.","title":"Strategies"},{"location":"strategies/#strategies","text":"A strategy producing one or more results lazily. To achieve this, they are implemented using coroutines and state machines. It may call other strategies lazily, when their results are needed. /* Let's look at the Fibonacci sequence as an example. The Tego following definition of fib returns an infinite sequence of Fibonacci numbers, starting with 0 and 1 : decl fib: Any -> [Int] fib = <generate(fib_next); fst> (0, 1). decl fib_next: (Int, Int) -> (Int, Int) fib_next n1, n2 = !(n2, <add> (n1, n2)). Its definition uses the ! operator, which is syntactic sugar for the built-in build strategy that takes a value and wraps it in a strategy. The strategy also uses the add and fst strategies, which add two integers in a tuple and project the first component of a tuple, respectively. Their signatures are: decl build<T>(T): Any -> T decl fst<T>: (T, Any) -> T decl add: (Int, Int) -> Int Finally, the strategy uses the special generate strategy, which produces an infinite sequence by applying a given strategy to the current value. It is defined as: */ Let's look at the generate strategy. This strategy takes an initial value and a strategy, and produces an infinite sequence of values. It is defined as follows: decl generate<T>(T -> T): T -> [T] generate(s) i = v := <s> i; ![v | <generate(s)> v]. Definition of generate The generate strategy is defined recursively, building the head of the sequence and recursively building the tail of the sequence.","title":"Strategies"},{"location":"develop/","text":"Developing Tego \u00b6 This section has not yet been written. Todo \u00b6 Generics Overloading Java extern declarations Java Class#member member syntax Wishlist \u00b6 Extract reference documentation from .tego files, write them as DocBook/Dita (or something else), and format them into markdown files for this documentation","title":"Developing Tego"},{"location":"develop/#developing-tego","text":"This section has not yet been written.","title":"Developing Tego"},{"location":"develop/#todo","text":"Generics Overloading Java extern declarations Java Class#member member syntax","title":"Todo"},{"location":"develop/#wishlist","text":"Extract reference documentation from .tego files, write them as DocBook/Dita (or something else), and format them into markdown files for this documentation","title":"Wishlist"},{"location":"develop/documentation/","text":"Documentation \u00b6 The Tego documentation follows the documentation system outlined by Daniele Procida . It divides the documentation into the following sections: Getting Started - Anything to do with getting started, finding releases, downloading source code, and installation. Tutorials - Practical learning instruments that show and explain various techniques and concepts by taking the user's hand toward a pre-defined goal. How-Tos - Practical problem-oriented guides on how to achieve a particular goal. Reference - Reference information. Background - Background information, explanations, and design documents. Develop - Information on contributing and the repository structure. Adding Pages \u00b6 When adding pages, add them to the nav: element in /mkdocs.yml in the root of this project as well.","title":"Documentation"},{"location":"develop/documentation/#documentation","text":"The Tego documentation follows the documentation system outlined by Daniele Procida . It divides the documentation into the following sections: Getting Started - Anything to do with getting started, finding releases, downloading source code, and installation. Tutorials - Practical learning instruments that show and explain various techniques and concepts by taking the user's hand toward a pre-defined goal. How-Tos - Practical problem-oriented guides on how to achieve a particular goal. Reference - Reference information. Background - Background information, explanations, and design documents. Develop - Information on contributing and the repository structure.","title":"Documentation"},{"location":"develop/documentation/#adding-pages","text":"When adding pages, add them to the nav: element in /mkdocs.yml in the root of this project as well.","title":"Adding Pages"},{"location":"develop/extract-reference-docs/","text":"Extract Reference \u00b6 To extract reference documentation from Tego declarations, one approach might be: annotate the AST with the term origins (locations) (or gather the locations through other means); perform a regex search on the code to find all the documentation blocks (either they start with /** and end with */ , or they start with /// and end at the end of the line); merge multiple consecutive documentation blocks into one, separated by newlines; associate documentation blocks with their corresponding declarations (usually the next declaration, next parameter declaration or next module declaration); parse the doc blocks (if necessary), such as extracting info in parameters or return values; generating documentation XML; generating markdown from XML. This approach may also be viable for other languages.","title":"Extract Reference"},{"location":"develop/extract-reference-docs/#extract-reference","text":"To extract reference documentation from Tego declarations, one approach might be: annotate the AST with the term origins (locations) (or gather the locations through other means); perform a regex search on the code to find all the documentation blocks (either they start with /** and end with */ , or they start with /// and end at the end of the line); merge multiple consecutive documentation blocks into one, separated by newlines; associate documentation blocks with their corresponding declarations (usually the next declaration, next parameter declaration or next module declaration); parse the doc blocks (if necessary), such as extracting info in parameters or return values; generating documentation XML; generating markdown from XML. This approach may also be viable for other languages.","title":"Extract Reference"},{"location":"howto/","text":"How-Tos \u00b6 This section has not yet been written.","title":"How-Tos"},{"location":"howto/#how-tos","text":"This section has not yet been written.","title":"How-Tos"},{"location":"reference/","text":"Reference \u00b6 No reference available yet.","title":"Reference"},{"location":"reference/#reference","text":"No reference available yet.","title":"Reference"},{"location":"reference/java-interop/","text":"Java Interop \u00b6 It is possible to call Java methods from Tego and use their results. Fully-Qualified Names \u00b6 Java types and members can be referenced using either their fully-qualified name or their shortened name. For example, the List type is referenced using its fully-qualified name as: java/util::List Or by using an explicit import: import java/util::List List Or using an implicit import: import java/util::* List Reference \u00b6 The following are examples to reference Java types and members in various situations: // Types Thread // class Runnable // interface DayOfWeek // enum Array<String> // array ArrayList<T> // generic class List<T> // generic interface $ // static nested class . // inner class // Static Members DayOfWeek#SUNDAY // enum field Collections#emptyList<T> // generic static function Int#MAX_VALUE // static field // Instance Members Pair<K, V>#getKey // instance method Instance Methods \u00b6 Java instance methods are implicitly declared as public external strategies that take a value of the receiver type as the implicit input parameter. For example, the length method defined on java/lang::String is represented in Tego as: extern module java/lang String#length: String -> Int Any additional parameters are parameters to the strategy. For example, the replace method defined on java/lang::String is declared as: extern module java/lang String#replace(Char, Char): String -> String Static Methods \u00b6 Java static methods are implicitly declared as public external strategies that take a value of type Any as the implicit input parameter and ignore it. However, the implicit argument can be captured using, say, <id> in place of an argument. For example, the java/util::Collections#emptyList static method is declared as: extern module java/util Collection#emptyList<T>: Any -> List<T> Again, like with instance methods, any additional parameters are parameters to the strategy.","title":"Java Interop"},{"location":"reference/java-interop/#java-interop","text":"It is possible to call Java methods from Tego and use their results.","title":"Java Interop"},{"location":"reference/java-interop/#fully-qualified-names","text":"Java types and members can be referenced using either their fully-qualified name or their shortened name. For example, the List type is referenced using its fully-qualified name as: java/util::List Or by using an explicit import: import java/util::List List Or using an implicit import: import java/util::* List","title":"Fully-Qualified Names"},{"location":"reference/java-interop/#reference","text":"The following are examples to reference Java types and members in various situations: // Types Thread // class Runnable // interface DayOfWeek // enum Array<String> // array ArrayList<T> // generic class List<T> // generic interface $ // static nested class . // inner class // Static Members DayOfWeek#SUNDAY // enum field Collections#emptyList<T> // generic static function Int#MAX_VALUE // static field // Instance Members Pair<K, V>#getKey // instance method","title":"Reference"},{"location":"reference/java-interop/#instance-methods","text":"Java instance methods are implicitly declared as public external strategies that take a value of the receiver type as the implicit input parameter. For example, the length method defined on java/lang::String is represented in Tego as: extern module java/lang String#length: String -> Int Any additional parameters are parameters to the strategy. For example, the replace method defined on java/lang::String is declared as: extern module java/lang String#replace(Char, Char): String -> String","title":"Instance Methods"},{"location":"reference/java-interop/#static-methods","text":"Java static methods are implicitly declared as public external strategies that take a value of type Any as the implicit input parameter and ignore it. However, the implicit argument can be captured using, say, <id> in place of an argument. For example, the java/util::Collections#emptyList static method is declared as: extern module java/util Collection#emptyList<T>: Any -> List<T> Again, like with instance methods, any additional parameters are parameters to the strategy.","title":"Static Methods"},{"location":"reference/modules/","text":"Modules \u00b6 A module in Tego is declared using the module keyword, followed by a fully-qualified identifier. The fully-qualified identifier consists of one or more identifiers separated by forward slashes. For example: module org/metaborg/tego Modules and Java Packages The name of a module determines the Java package in which the generated classes are placed. In the example above, any strategies are generated into the org.metaborg.tego Java package. Extending Modules It is allowed to have multiple declarations of the same module name. Their classes will be generated into the same packages. However, it is not allowed to have duplicate or overlapping declarations in different modules. So it is not possible to provide additional definitions of a strategy in a separate module, even if they have the same name.","title":"Modules"},{"location":"reference/modules/#modules","text":"A module in Tego is declared using the module keyword, followed by a fully-qualified identifier. The fully-qualified identifier consists of one or more identifiers separated by forward slashes. For example: module org/metaborg/tego Modules and Java Packages The name of a module determines the Java package in which the generated classes are placed. In the example above, any strategies are generated into the org.metaborg.tego Java package. Extending Modules It is allowed to have multiple declarations of the same module name. Their classes will be generated into the same packages. However, it is not allowed to have duplicate or overlapping declarations in different modules. So it is not possible to provide additional definitions of a strategy in a separate module, even if they have the same name.","title":"Modules"},{"location":"reference/strategies/","text":"Strategies \u00b6 A strategy in Tego is a function that takes an implicit argument and performs an operation on it to produce a value. A strategy needs to be declared, after which it can be defined. For example, the following declares a strategy stringLength that takes a String and produces an Int . def stringLength: String -> Int The strategy is defined to use the String.length() instance method (in Java) to return the length of the string: stringLength = String#length. A single strategy declaration can have multiple strategy definitions. Strategies are evaluated in the order they appear in the module, and the first definition that succeeds determines the final result. For example, the following strategy inc increments an integer or floating-point value: def inc<T: Number>: T -> T? inc = as-Int; Integer#sum(<id>, 1.0) inc = as-Float; Float#sum(<id>, 1.0)","title":"Strategies"},{"location":"reference/strategies/#strategies","text":"A strategy in Tego is a function that takes an implicit argument and performs an operation on it to produce a value. A strategy needs to be declared, after which it can be defined. For example, the following declares a strategy stringLength that takes a String and produces an Int . def stringLength: String -> Int The strategy is defined to use the String.length() instance method (in Java) to return the length of the string: stringLength = String#length. A single strategy declaration can have multiple strategy definitions. Strategies are evaluated in the order they appear in the module, and the first definition that succeeds determines the final result. For example, the following strategy inc increments an integer or floating-point value: def inc<T: Number>: T -> T? inc = as-Int; Integer#sum(<id>, 1.0) inc = as-Float; Float#sum(<id>, 1.0)","title":"Strategies"},{"location":"start/","text":"Getting Started \u00b6 Install Tego \u00b6 Download the latest release, or find an older release and the source code . Tego Stable 0.1","title":"Getting Started"},{"location":"start/#getting-started","text":"","title":"Getting Started"},{"location":"start/#install-tego","text":"Download the latest release, or find an older release and the source code . Tego Stable 0.1","title":"Install Tego"},{"location":"start/releases/","text":"Releases \u00b6 Stable Releases \u00b6 No stable Tego releases have been made yet. Development Releases \u00b6 No development Tego releases have been made yet. Source Code \u00b6 To get the latest source code of Tego, which may or may not work for you, go to the Tego Github repository. Tego Github repository To clone and build the Tego repository locally: HTTPS git clone https://github.com/Virtlink/tego-lang.git ./gradlew build SSL git clone git@github.com:Virtlink/tego-lang.git ./gradlew build","title":"Releases"},{"location":"start/releases/#releases","text":"","title":"Releases"},{"location":"start/releases/#stable-releases","text":"No stable Tego releases have been made yet.","title":"Stable Releases"},{"location":"start/releases/#development-releases","text":"No development Tego releases have been made yet.","title":"Development Releases"},{"location":"start/releases/#source-code","text":"To get the latest source code of Tego, which may or may not work for you, go to the Tego Github repository. Tego Github repository To clone and build the Tego repository locally: HTTPS git clone https://github.com/Virtlink/tego-lang.git ./gradlew build SSL git clone git@github.com:Virtlink/tego-lang.git ./gradlew build","title":"Source Code"},{"location":"tutorial/","text":"Tutorials \u00b6 This section has not yet been written. Tutorial 1","title":"Tutorials"},{"location":"tutorial/#tutorials","text":"This section has not yet been written. Tutorial 1","title":"Tutorials"},{"location":"tutorial/tutorial1/","text":"","title":"Tutorial 1"}]}