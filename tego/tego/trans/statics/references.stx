module statics/references

imports
  signatures/Tego-sig

  statics/declarations
  statics/expressions
  statics/modules
  statics/types

signature
  sorts
    DECL = (path * (occurrence * TYPE))

signature
  namespaces
  relations
    type     : ID -> TYPE
  name-resolution
    labels
      P      // laxical parent
      I      // import edge


// Imports all declarations of the specified scope into the current scope
rules importAll : scope * scope

  importAll(s, s_import) :-
    s -I-> s_import.


// Imports one declaration with the specified name and type into the current scope
rules importOne : scope * string * TYPE

  importOne(is, name, T) :-
    !type[name, T] in is.


// Declares a declaration with the given name in the appropriate given scope
// as dicatated by the declaration modifiers
rules declareDeclWithMods : scope * scope * string * TYPE * list(DeclMod)

  declareDeclWithMods(s_priv, s_pub, name, T, [PublicDecl()|_]) :-
    // public
    declareDecl(s_pub, name, T).

  declareDeclWithMods(s_priv, s_pub, name, T, [_|mods]) :-
    // unknown
    declareDeclWithMods(s_priv, s_pub, name, T, mods).

  declareDeclWithMods(s_priv, s_pub, name, T, []) :-
    // private
    declareDecl(s_priv, name, T).


// Declares a declaration with the given name and type in the given scope
rules declareDecl : scope * string * TYPE

  declareDecl(s, name, T) :-
    !type[name, T] in s,
    // For compilation and to support renaming,
    // we need @decl on the name of the declaration.
    @name.decl := name.


// Resolves a declaration with the given name in the given scope to a type
rules resolveDecl : scope * string -> TYPE

  resolveDecl(s, name) = T :- {decl}
    query type
      filter P* I?
      and { d' :- d' == name }
      min $ < P, $ < I
      in s |-> [(_, (decl, T))],
    // For compilation and to support renaming,
    // we need @ref on the name of the reference
    // pointing to the name of the declaration.
    @name.ref := decl.


// Declares the module with the specified name and scope and returns its type
rules declareModule : scope * string * scope -> TYPE

  declareModule(s, name, ms_pub) = T :-
    MODULE(ms_pub) == T,
    !type[name, T] in s.


// Resolves the module with the specified name to its scope
rules resolveModule : scope * string -> scope

  resolveModule(s, name) = ms :-
    resolveDecl(s, name) == MODULE(ms).
