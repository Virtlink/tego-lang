module statics

imports
  signatures/Tego-sig

// Single-file entry point
rules programOk : File

  programOk(file) :- {s}
    new s,
    init(s),
    fileOk(s, file).

// Multi-file entry point
rules projectOk : scope

  projectOk(s) :-
    init(s).

rules fileOk : scope * File

  fileOk(s, File(modules)) :- modulesOk(s, modules).

  fileOk(s, File-Plhdr()).

rules init : scope

  init(s) :- true.

rules moduleOk : scope * Module
  modulesOk maps moduleOk(*, list(*))

  moduleOk(s, Module(name, imports, decls)) :- {ms is}
    new ms, ms -P-> s,
    declareModule(s, name, ms),
    importsOk(s, ms, imports),
    declsOk(ms, decls).

  moduleOk(s, Module-Plhdr()).

rules importOk : scope * scope * Import
  importsOk maps importOk(*, *, list(*))

  importOk(s, ms, d@Import(moduleName, name)) :- {ims is T}
    resolveModule(s, moduleName) == ims,
    resolveDecl(ims, name) == T,
    new is, ms -I-> is,
    declareImportDecl(is, name, T),
    @d.type := T.

  importOk(s, ms, d@ImportAll(moduleName)) :- {ims}
    resolveModule(s, moduleName) == ims,
    declareImportAll(ms, ims).

  importOk(s, ms, Import-Plhdr()).

rules declOk : scope * Decl
  declsOk maps declOk(*, list(*))

  declOk(s, d@ValDef(mods, name, type, body)) :- {T TBODY}
    typeOfType(s, type) == T,
    typeOfExp(s, body) == TBODY,
    TBODY == T,
    declareDecl(s, name, T),
    @d.type := T.

  declOk(s, d@ValDefNoType(mods, name, body)) :- {T TBODY}
    typeOfExp(s, body) == T,
    declareDecl(s, name, T),
    @d.type := T.

  declOk(s, d@ValDecl(mods, name, type)) :- {T}
    typeOfType(s, type) == T,
    declareDecl(s, name, T),
    @d.type := T.

  declOk(s, d@StrategyDecl(mods, name, [], params, inType, outType)) :- {ds TPs T PTs IT OT}
    // Create strategy declaration scope in which the type variables are declared
    new ds, ds -P-> s,
    typesOfTypes(ds, params) == PTs,
    typeOfType(ds, inType) == IT,
    typeOfType(ds, outType) == OT,
    T == STRATEGY(PTs, IT, OT),
    declareDecl(s, name, T),
    @d.type := T.

  // TODO: Support generics
  declOk(s, d@StrategyDecl(_, _, _, _, _, _)).

  declOk(s, d@StrategyDef(name, paramDefs, body)) :- {T PTs IT OT ss}
    typeOfType(s, TypeRef(name)) == T@STRATEGY(PTs, IT, OT),
    new ss, ss -P-> s,
    typesOfParamDefs(ss, paramDefs) == PTs,
    typeOfExp(ss, body) == STRATEGY([], IT, OT),
    @d.type := T.

  declOk(s, d@StrategyDefWInput(name, paramDefs, bindInput, body)) :- {T PTs IT OT ss}
    typeOfType(s, TypeRef(name)) == T@STRATEGY(PTs, IT, OT),
    new ss, ss -P-> s,
    typesOfParamDefs(ss, paramDefs) == PTs,
    declareDecl(ss, bindInput, IT),
    @bindInput.type := IT,
    typeOfExp(ss, body) == OT,
    @d.type := T.

  declOk(s, d@RuleDef(name, paramDefs, inExp, outExp, clauses)) :- {T PTs IT OT ss}
    typeOfType(s, TypeRef(name)) == T@STRATEGY(PTs, IT, OT),
    new ss, ss -P-> s,
    typesOfParamDefs(ss, paramDefs) == PTs,
    typeOfExp(ss, inExp) == IT,
    typeOfExp(ss, outExp) == OT,
    clausesOk(ss, clauses),
    @d.type := T.

  declOk(s, d@ClassDecl(mods, name)) :- {T}
    T == CLASS(name),
    declareDecl(s, name, T),
    @d.type := T.


  declOk(s, Decl-Plhdr()).

rules typeOfType : scope * Type -> TYPE
  typesOfTypes maps typeOfType(*, list(*)) = list(*)

  typeOfType(s, t@StrategyType(paramTypes, inputType, outputType)) = T@STRATEGY(PTs, IT, OT) :-
    typesOfTypes(s, paramTypes) == PTs,
    typeOfType(s, inputType) == IT,
    typeOfType(s, outputType) == OT,
    @t.type := T.

  typeOfType(s, t@AnyType()) = T@ANY() :-
    @t.type := T.

  typeOfType(s, t@UnitType()) = T@UNIT() :-
    @t.type := T.

  typeOfType(s, t@BoolType()) = T@BOOL() :-
    @t.type := T.

  typeOfType(s, t@IntType()) = T@INT() :-
    @t.type := T.

  typeOfType(s, t@ListType(type)) = T@LIST(ET) :-
    typeOfType(s, type) == ET,
    @t.type := T.

  typeOfType(s, t@TypeRef(name)) = T :-
    resolveDecl(s, name) == T,
    @t.type := T.

  typeOfType(s, t@MemberTypeRef(rcv, name)) = T :- {T_rcv s_rcv}
    typeOfType(s, rcv) == T_rcv,
    getScope(T_rcv) == s_rcv,
    resolveDecl(s_rcv, name) == T,
    @t.type := T.

  typeOfType(s, t@TupleType(types)) = T@TUPLE(Ts) :-
    typesOfTypes(s, types) == Ts,
    @t.type := T.

  typeOfType(s, t@WldType()) = T :-
    @t.type := T.

  typeOfType(s, Type-Plhdr()) = _.


rules typeOfParamDef : scope * ParamDef -> TYPE
  typesOfParamDefs maps typeOfParamDef(*, list(*)) = list(*)

  typeOfParamDef(s, p@ParamDef(name, type)) = T :-
    typeOfType(s, type) == T,
    declareDecl(s, name, T),
    @p.type := T.

  typeOfParamDef(s, p@ParamDefNoType(name)) = T :-
    declareDecl(s, name, T),
    @p.type := T.

  typeOfParamDef(s, ParamDef-Plhdr()) = T.

rules typeOfExp : scope * Exp -> TYPE
  typesOfExps maps typeOfExp(*, list(*)) = list(*)

  typeOfExp(s, e@Seq(e1, e2)) = T :- {IT MT OT}
    typeOfExp(s, e1) == STRATEGY([], IT, MT),
    typeOfExp(s, e2) == STRATEGY([], MT, OT),
    T == STRATEGY([], IT, OT),
    @e.type := T.

  typeOfExp(s, e@Map(e1, e2)) = T :- {IT MT OT}
    typeOfExp(s, e1) == STRATEGY([], IT, LIST(MT)),
    typeOfExp(s, e2) == STRATEGY([], MT, OT),
    T == STRATEGY([], IT, LIST(OT)),
    @e.type := T.

  typeOfExp(s, e@FlatMap(e1, e2)) = T :- {IT MT OT}
    typeOfExp(s, e1) == STRATEGY([], IT, LIST(MT)),
    typeOfExp(s, e2) == STRATEGY([], MT, LIST(OT)),
    T == STRATEGY([], IT, LIST(OT)),
    @e.type := T.

  typeOfExp(s, e@Id()) = T@STRATEGY([], ANY(), ANY()) :-
    @e.type := T.

  typeOfExp(s, e@Fail()) = T :- //@STRATEGY([], ANY(), ANY()) :-
    @e.type := T.

  typeOfExp(s, e@Apply(rcv, args)) = T :- {ET TAs PTs IT OT}
    typeOfExp(s, rcv) == STRATEGY(PTs, IT, OT),
    typesOfExps(s, args) == PTs,
    T == STRATEGY([], IT, OT),
    @e.type := T.

  typeOfExp(s, e@Var(name)) = T :-
    resolveDecl(s, name) == T,
    @e.type := T.

  typeOfExp(s, e@Member(rcv, name)) = T :- {T_rcv s_rcv}
    typeOfExp(s, rcv) == T_rcv,
    getScope(T_rcv) == s_rcv,
    resolveDecl(s_rcv, name) == T,
    @e.type := T.

  // FIXME: Should be Class<T> where T is the type
  typeOfExp(s, e@ClassRef(type)) = T@CLASS("Class") :-
    typeOfType(s, type) == CLASS(_),
    @e.type := T.

  // FIXME: This is incorrect since we want to be able to cast literals to any of the integer types
  typeOfExp(s, e@Int(_)) = T@INT() :-
    @e.type := T.

  typeOfExp(s, e@String(_)) = T@STRING() :-
    @e.type := T.

  typeOfExp(s, e@Object()) = T@ANY() :-
    @e.type := T.

  typeOfExp(s, e@True()) = T@BOOL() :-
    @e.type := T.

  typeOfExp(s, e@False()) = T@BOOL() :-
    @e.type := T.

  // TODO: Accept ANY() as input type
  typeOfExp(s, e@Build(exp)) = T@STRATEGY([], _, TEXP) :-
    typeOfExp(s, exp) == TEXP,
    @e.type := T.

  typeOfExp(s, e@Eval(rcv, exp)) = OT :- {IT}
    typeOfExp(s, rcv) == STRATEGY([], IT, OT),
    typeOfExp(s, exp) == IT,
    @e.type := OT.

  typeOfExp(s, e@Let(bindName, bindExp, body)) = T :- {BT ls}
    typeOfExp(s, bindExp) == BT,
    new ls, ls -P-> s,
    declareDecl(ls, bindName, BT),
    typeOfExp(ls, body) == T,
    @bindName.type := BT,
    @e.type := T.

  typeOfExp(s, e@Tuple(exps)) = T@TUPLE(Ts) :-
    typesOfExps(s, exps) == Ts,
    @e.type := T.

  typeOfExp(s, e@LambdaRule(paramDefs, inExp, outExp)) = T@STRATEGY(PTs, IT, OT) :- {ss}
    new ss, ss -P-> s,
    typesOfParamDefs(ss, paramDefs) == PTs,
    typeOfExp(ss, inExp) == IT,
    typeOfExp(ss, outExp) == OT,
    T == STRATEGY(PTs, IT, OT),
    @e.type := T.

  typeOfExp(s, e@LambdaStrategy(paramDefs, exp)) = T@STRATEGY(PTs, IT, OT) :- {ss}
    new ss, ss -P-> s,
    typesOfParamDefs(ss, paramDefs) == PTs,
    typeOfExp(ss, exp) == STRATEGY([], IT, OT),
    T == STRATEGY(PTs, IT, OT),
    @e.type := T.

  typeOfExp(s, Exp-Plhdr()) = T.

rules clauseOk : scope * RuleClause
  clausesOk maps clauseOk(*, list(*))

  clauseOk(s, WhereClause(exp)) :-
    typeOfExp(s, exp) == UNIT().

rules declareTypeParam : scope * TypeParamDecl * TYPE
  declareTypeParams maps declareTypeParam(*, list(*), list(*))

  declareTypeParam(ts, TypeParamDecl(name), T) :-
    !type[TypeParam{name@_}, T] in ts.

rules declareModule : scope * string * scope

  declareModule(s, name, ms) :-
    !type[Decl{name@name}, MODULE(ms)] in s.

rules resolveModule : scope * string -> scope

  resolveModule(s, name) = ms :-
    resolveDecl(s, name) == MODULE(ms).

rules declareImportAll : scope * scope

  declareImportAll(s, s2) :-
    s -I-> s2.

rules declareImportDecl : scope * string * TYPE

  declareImportDecl(is, name, T) :-
    !type[Decl{name@name}, T] in is.

rules declareDecl : scope * string * TYPE

  declareDecl(s, name, T) :-
    !type[Decl{name@name}, T] in s.

rules resolveDecl : scope * string -> TYPE

  resolveDecl(s, name) = T :-
    query type
      filter P* I?
      and { d' :- d' == Decl{name@_} }
      min $ < P, $ < I
      in s |-> [(_, (_, T))].

rules getScope : TYPE -> scope

  getScope(MODULE(s)) = s.

signature
  sorts TYPE
  constructors
    MODULE   : scope -> TYPE
    STRATEGY : list(TYPE) * TYPE * TYPE -> TYPE
    CLASS    : string -> TYPE
    LIST     : TYPE -> TYPE
    TUPLE    : list(TYPE) -> TYPE

    BYTE     : TYPE
    SHORT    : TYPE
    INT      : TYPE
    LONG     : TYPE

    UBYTE    : TYPE
    USHORT   : TYPE
    UINT     : TYPE
    ULONG    : TYPE

    ANY      : TYPE
    BOOL     : TYPE
    UNIT     : TYPE
    STRING   : TYPE
  sorts
    DECL = (path * (occurrence * TYPE))

signature
  namespaces
    //Module    : ID
    Decl      : ID
    TypeParam : ID
  relations
    type     : occurrence -> TYPE
  name-resolution
    labels
      P      // laxical parent
      I      // import edge
