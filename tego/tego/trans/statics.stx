module statics

imports
  signatures/Tego-sig

// Single-file entry point
rules programOk : Module

  programOk(module) :- {s}
    new s,
    init(s),
    moduleOk(s, module).

// Multi-file entry point
rules projectOk : scope

  projectOk(s) :-
    init(s).

rules fileOk : scope * Module

  fileOk(s, module) :- moduleOk(s, module).

rules init : scope

  init(s) :- true.

rules moduleOk : scope * Module

  moduleOk(s, Module(moduleDecl, decls)) :- {ms}
    new ms, ms -P-> s,
    moduleDeclOk(s, moduleDecl, ms),
    declsOk(ms, decls).

  moduleOk(s, Module-Plhdr()).

rules moduleDeclOk : scope * ModuleDecl * scope

  moduleDeclOk(s, ModuleDecl(name), ms) :-
    declareModule(s, name, ms).

  moduleDeclOk(s, ModuleDecl-Plhdr(), ms).

rules declOk : scope * Decl
  declsOk maps declOk(*, list(*))

  declOk(s, d@ValDef(mods, name, type, body)) :- {T TBODY}
    typeOfType(s, type) == T,
    typeOfExpInst(s, body) == TBODY,
    subtypeOf(TBODY, T),
    declareDecl(s, name, T),
    @d.type := T.

  declOk(s, d@ValDefNoType(mods, name, body)) :- {T TBODY}
    typeOfExpInst(s, body) == T,
    declareDecl(s, name, T),
    @d.type := T.

  declOk(s, d@ValDecl(mods, name, type)) :- {T}
    typeOfType(s, type) == T,
    declareDecl(s, name, T),
    @d.type := T.

  declOk(s, d@StrategyDecl(mods, name, typeParams, params, inType, outType)) :- {ds TPs T PTs IT OT}
    // Create strategy declaration scope in which the type variables are declared
    new ds, ds -P-> s,
    typeParamDeclsOk(ds, typeParams),
    typesOfTypes(ds, params) == PTs,
    typeOfType(ds, inType) == IT,
    typeOfType(ds, outType) == OT,
    T == GENERIC(typeParams, STRATEGY(PTs, IT, OT)),
    declareDecl(s, name, T),
    @d.type := T.

  declOk(s, d@StrategyDef(name, paramDefs, body)) :- {T PTs IT OT ss}
    // TODO: instantiate the generic type to its bounds
    typeOfType(s, TypeRef(name)) == T@GENERIC(_, STRATEGY(PTs, IT, OT)),
    new ss, ss -P-> s,
    paramDefsOk(ss, paramDefs, PTs),
    typeOfExpInst(ss, body) == STRATEGY([], IT, OT),
    @d.type := T.

  declOk(s, d@RuleDef(name, paramDefs, inExp, outExp)) :- {T PTs IT OT ss}
    // TODO: instantiate the generic type to its bounds
    typeOfType(s, TypeRef(name)) == T@GENERIC(_, STRATEGY(PTs, IT, OT)),
    new ss, ss -P-> s,
    paramDefsOk(ss, paramDefs, PTs),
    typeOfExpInst(ss, inExp) == IT,
    typeOfExpInst(ss, outExp) == OT,
    @d.type := T.

  declOk(s, d@ClassDecl(mods, name)) :- {T}
    T == CLASS(name),
    declareDecl(s, name, T),
    @d.type := T.


  declOk(s, Decl-Plhdr()).

rules typeOfType : scope * Type -> TYPE
  typesOfTypes maps typeOfType(*, list(*)) = list(*)

  typeOfType(s, t@StrategyType(paramTypes, inputType, outputType)) = T@STRATEGY(PTs, IT, OT) :-
    typesOfTypes(s, paramTypes) == PTs,
    typeOfType(s, inputType) == IT,
    typeOfType(s, outputType) == OT,
    @t.type := T.

  typeOfType(s, t@AnyType()) = T@ANY() :-
    @t.type := T.

  typeOfType(s, t@UnitType()) = T@UNIT() :-
    @t.type := T.

  typeOfType(s, t@BoolType()) = T@BOOL() :-
    @t.type := T.

  typeOfType(s, t@IntType()) = T@INT() :-
    @t.type := T.

  typeOfType(s, t@ListType(type)) = T@LIST(ET) :-
    typeOfType(s, type) == ET,
    @t.type := T.

  typeOfType(s, t@TypeRef(name)) = T :-
    resolveDecl(s, name) == T,
    @t.type := T.

  typeOfType(s, t@TupleType(types)) = T@TUPLE(Ts) :-
    typesOfTypes(s, types) == Ts,
    @t.type := T.

  typeOfType(s, t@WldType()) = T :-
    @t.type := T.

  typeOfType(s, Type-Plhdr()) = _.

//rules typeParamDeclOk : scope * TypeParamDecl
//  typeParamDeclsOk maps typeParamDeclOk(*, list(*))
//
//  // FIXME: This is incorrect because we use the same constraint variable
//  // for all instantiations
//  typeParamDeclOk(s, p@TypeParamDecl(name)) :- {T}
//    // A type parameter, unconstrained
//    declareDecl(s, name, T),
//    @p.type := T.
//
//  typeParamDeclOk(s, TypeParamDecl-Plhdr()).

// Declares each type parameter p as having type VAR(p).
rules typeParamDeclOk : scope * TypeParamDecl
  typeParamDeclsOk maps typeParamDeclOk(*, list(*))

  typeParamDeclOk(ds, p@TypeParamDecl(name)) :- {T}
    T == VAR(name),
    declareDecl(ds, name, T),
    @p.type := T.

//rules typeOfTypeParamDecl : scope * TypeParamDecl -> TYPE
//  typesOfTypeParamDecls maps typeOfTypeParamDecl(*, list(*)) = list(*)
//
//  // This creates a unconstrained type variable T
//  typeOfTypeParamDecl(s, p@TypeParamDecl(name)) = T :-
//    // A type parameter, unconstrained
//    T == VAR(name),
//    declareDecl(s, name, T),
//    @p.type := T.
//
//  typeOfTypeParamDecl(s, TypeParamDecl-Plhdr()) = _.

rules typeOfParamDecl : scope * scope * ParamDecl -> TYPE
  typesOfParamDecls maps typeOfParamDecl(*, *, list(*)) = list(*)

  typeOfParamDecl(s, fs, p@ParamDecl(name, type)) = T :-
    typeOfType(s, type) == T,
    declareDecl(fs, name, T),
    @p.type := T.

rules paramDefOk : scope * ParamDef * TYPE
  paramDefsOk maps paramDefOk(*, list(*), list(*))

  paramDefOk(s, p@ParamDef(name), T) :-
    declareDecl(s, name, T),
    @p.type := T.

  paramDefOk(s, ParamDef-Plhdr(), T).

rules typeOfExp : scope * Exp -> TYPE
  typesOfExps maps typeOfExp(*, list(*)) = list(*)

  typeOfExp(s, e@Seq(e1, e2)) = T :- {IT MT OT}
    typeOfExpInst(s, e1) == STRATEGY([], IT, MT),
    typeOfExpInst(s, e2) == STRATEGY([], MT, OT),
    T == STRATEGY([], IT, OT),
    @e.type := T.

  typeOfExp(s, e@Map(e1, e2)) = T :- {IT MT OT}
    typeOfExpInst(s, e1) == STRATEGY([], IT, LIST(MT)),
    typeOfExpInst(s, e2) == STRATEGY([], MT, OT),
    T == STRATEGY([], IT, LIST(OT)),
    @e.type := T.

  typeOfExp(s, e@FlatMap(e1, e2)) = T :- {IT MT OT}
    typeOfExpInst(s, e1) == STRATEGY([], IT, LIST(MT)),
    typeOfExpInst(s, e2) == STRATEGY([], MT, LIST(OT)),
    T == STRATEGY([], IT, LIST(OT)),
    @e.type := T.

  typeOfExp(s, e@Id()) = T@GENERIC([TypeParamDecl("T")], STRATEGY([], VAR("T"), VAR("T"))) :-
    @e.type := T.

  typeOfExp(s, e@Fail()) = T@GENERIC([TypeParamDecl("T"), TypeParamDecl("R")], STRATEGY([], VAR("T"), VAR("R"))) :-
    @e.type := T.

  typeOfExp(s, e@Apply(rcv, args)) = T :- {ET TAs PTs IT OT}
    typeOfExpInst(s, rcv) == STRATEGY(PTs, IT, OT),
    typesOfExpsInst(s, args) == PTs,
    T == STRATEGY([], IT, OT),
    @e.type := T.

//  typeOfExp(s, e@Eval(rcv, input)) = OT :- {IT}
//    typeOfExpInst(s, rcv) == STRATEGY(IT, OT),
//    typeOfExpInst(s, input) == IT,
//    @e.type := OT.

  typeOfExp(s, e@Var(name)) = T :-
    resolveDecl(s, name) == T,
    @e.type := T.

  // FIXME: This is incorrect since we want to be able to cast literals to any of the integer types
  typeOfExp(s, e@Int(_)) = T@INT() :-
    @e.type := T.

  typeOfExp(s, e@String(_)) = T@STRING() :-
    @e.type := T.

  typeOfExp(s, e@Object()) = T@ANY() :-
    @e.type := T.

  typeOfExp(s, e@True()) = T@BOOL() :-
    @e.type := T.

  typeOfExp(s, e@False()) = T@BOOL() :-
    @e.type := T.

  // TODO: Accept ANY() as input type
  typeOfExp(s, e@Build(exp)) = T@STRATEGY([], _, TEXP) :-
    typeOfExpInst(s, exp) == TEXP,
    @e.type := T.

  typeOfExp(s, e@Tuple(exps)) = T@TUPLE(Ts) :-
    typesOfExps(s, exps) == Ts,
    @e.type := T.

  typeOfExp(s, e@Inst(exp, typeArgs)) = T :- {ET TAs}
    typeOfExpInst(s, exp) == ET,
    typesOfTypes(s, typeArgs) == TAs,
    instantiateType(ET, TAs) == T.

//  typeOfExp(s, e@InstInfer(exp)) = T :- {ET}
//    typeOfExp(s, exp) == ET,
//    instantiateType(ET, _) == T.

  typeOfExp(s, e@LambdaRule(paramDefs, inExp, outExp)) = T@STRATEGY(PTs, IT, OT) :- {ss}
    new ss, ss -P-> s,
    paramDefsOk(ss, paramDefs, PTs),
    typeOfExpInst(ss, inExp) == IT,
    typeOfExpInst(ss, outExp) == OT,
    T == STRATEGY(PTs, IT, OT),
    @e.type := T.

  typeOfExp(s, e@LambdaStrategy(paramDefs, exp)) = T@STRATEGY(PTs, IT, OT) :- {ss}
    new ss, ss -P-> s,
    paramDefsOk(ss, paramDefs, PTs),
    typeOfExpInst(ss, exp) == STRATEGY([], IT, OT),
    T == STRATEGY(PTs, IT, OT),
    @e.type := T.

  typeOfExp(s, Exp-Plhdr()) = T.

rules typeOfExpInst : scope * Exp -> TYPE
  typesOfExpsInst maps typeOfExpInst(*, list(*)) = list(*)

  typeOfExpInst(s, exp) = T :- {ET}
    typeOfExp(s, exp) == ET,
    instantiateType(ET, _ /* No particular type suggestions */) == T.

rules subtypeOf : TYPE * TYPE

  subtypeOf(T, T).

rules instantiateType : TYPE * list(TYPE) -> TYPE

  // If the type is generic, instantiate it
  instantiateType(GENERIC(typeParams, T), TAs) = typeOfInstantiatedType(ts, T) :-
    // Each type parameter is a parameter name that occurs in T
    // By creating a scope, adding these parameters (with their corresponding TA type argument as the type),
    // and resolving them, we obtain a type instantiation.
    new ts,
    declareTypeParams(ts, typeParams, TAs).

  // If the type is not generic, the type arguments list must be empty
  instantiateType(T, []) = typeOfInstantiatedType(ts, T) :- new ts.

rules typeOfInstantiatedType : scope * TYPE -> TYPE
  typesOfInstantiatedTypes maps typeOfInstantiatedType(*, list(*)) = list(*)

//  typeOfInstantiatedType(ts, T@MODULE(_)) = T.

  typeOfInstantiatedType(ts, STRATEGY(PTs, IT, OT))
    = STRATEGY(typesOfInstantiatedTypes(ts, PTs), typeOfInstantiatedType(ts, IT), typeOfInstantiatedType(ts, OT)).
  typeOfInstantiatedType(ts, LIST(T))
    = LIST(typeOfInstantiatedType(ts, T)).
  typeOfInstantiatedType(ts, TUPLE(Ts))
    = TUPLE(typesOfInstantiatedTypes(ts, Ts)).

  typeOfInstantiatedType(ts, T@GENERIC(_, _))
    = _ :- false | error $[An uninstantiated generic type cannot occur in an uninstantiated generic type: [T]].

// typeOfInstantiatedType(_, ?) = num
// only if ? == VAR(_) then pick the VAR alternative


  // TODO: Don't pick this one if we don't know the lhs
  typeOfInstantiatedType(ts, VAR(name)) = T :-
    query type
      filter P*
      and { d' :- d' == TypeParam{name@_} }
      min $ < P
      in ts |-> [(_, (_, T))].

//  typeOfInstantiatedType(ts, T@CLASS(_)) = T.
//
//  typeOfInstantiatedType(ts, T@BYTE()) = T.
//  typeOfInstantiatedType(ts, T@SHORT()) = T.
//  typeOfInstantiatedType(ts, T@INT()) = T.
//  typeOfInstantiatedType(ts, T@LONG()) = T.
//
//  typeOfInstantiatedType(ts, T@UBYTE()) = T.
//  typeOfInstantiatedType(ts, T@USHORT()) = T.
//  typeOfInstantiatedType(ts, T@UINT()) = T.
//  typeOfInstantiatedType(ts, T@ULONG()) = T.
//
//  typeOfInstantiatedType(ts, T@ANY()) = T.
//  typeOfInstantiatedType(ts, T@BOOL()) = T.
//  typeOfInstantiatedType(ts, T@UNIT()) = T.
//  typeOfInstantiatedType(ts, T@STRING()) = T.

  // Else:
  typeOfInstantiatedType(_, T) = T.

rules declareTypeParam : scope * TypeParamDecl * TYPE
  declareTypeParams maps declareTypeParam(*, list(*), list(*))

  declareTypeParam(ts, TypeParamDecl(name), T) :-
    !type[TypeParam{name@_}, T] in ts.


rules declareModule : scope * string * scope

  declareModule(s, name, ms) :-
    !type[Module{name@name}, MODULE(ms)] in s.

rules declareDecl : scope * string * TYPE

  declareDecl(s, name, T) :-
    !type[Decl{name@name}, T] in s.

rules resolveDecl : scope * string -> TYPE

  resolveDecl(s, name) = T :-
    query type
      filter P*
      and { d' :- d' == Decl{name@_} }
      min $ < P
      in s |-> [(_, (_, T))|_].

signature
  sorts TYPE
  constructors
    MODULE   : scope -> TYPE
    STRATEGY : list(TYPE) * TYPE * TYPE -> TYPE
    CLASS    : string -> TYPE
    LIST     : TYPE -> TYPE
    TUPLE    : list(TYPE) -> TYPE

    GENERIC  : list(TypeParamDecl) * TYPE -> TYPE
    VAR      : string -> TYPE

    BYTE     : TYPE
    SHORT    : TYPE
    INT      : TYPE
    LONG     : TYPE

    UBYTE    : TYPE
    USHORT   : TYPE
    UINT     : TYPE
    ULONG    : TYPE

    ANY      : TYPE
    BOOL     : TYPE
    UNIT     : TYPE
    STRING   : TYPE
  sorts
    DECL = (path * (occurrence * TYPE))

signature
  namespaces
    Module    : ID
    Decl      : ID
    TypeParam : ID
  relations
    type     : occurrence -> TYPE
  name-resolution
    labels
      P      // laxical parent
