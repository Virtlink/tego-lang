module Tego

imports

  Common

context-free start-symbols

  File

context-free sorts File
context-free syntax

  File.File = <<{Module "\n\n"}*>>

context-free sorts Module
context-free syntax

  Module.Module = <<{ModuleMod " "}*> module <MOD_ID>

    <{Import "\n"}*>

    <{Decl "\n"}*>>

context-free sorts Import
context-free syntax

  Import.Import                 = [import [MOD_ID]::[ID]]
  Import.ImportAll              = [import [MOD_ID]::[]*]

context-free sorts Decl
context-free syntax

  Decl.ValDef                   = [[{DeclMod " "}*] val [ID]: [Type] = [Exp].]
  Decl.ValDecl                  = [[{DeclMod " "}*] val [ID]: [Type]]
  Decl.ValDefNoType             = [[{DeclMod " "}*] val [ID] = [Exp].]

  Decl.StrategyDecl             = [[{DeclMod " "}*] def [ID]<[{TypeParamDecl ", "}*]>([{Type ", "}*]): [Type] -> [Type]]
  Decl.StrategyDeclNoParams     = [[{DeclMod " "}*] def [ID]<[{TypeParamDecl ", "}*]>: [Type] -> [Type]] // desugared
  Decl.StrategyDeclNoTypeParams = [[{DeclMod " "}*] def [ID]([{Type ", "}*]): [Type] -> [Type]] // desugared
  Decl.StrategyDeclNoParamsOrTypeParams = [[{DeclMod " "}*] def [ID]: [Type] -> [Type]]        // desugared

  Decl.StrategyDef              = [[ID]([{ParamDef ", "}*]) =
  [Exp].]         // desugared
  Decl.StrategyDefNoParams      = [[ID] =
  [Exp].]        // desugared

  Decl.StrategyDefWInput        = [[ID]([{ParamDef ", "}*]) [ID] =
  [Exp].]
  Decl.StrategyDefWInputNoParams= [[ID] [ID] =
  [Exp].] // desugared

  Decl.RuleDef                  = [[ID]([{ParamDef ", "}*]) :- [Exp] -> [Exp],
  [{RuleClause ", "}+].]
  Decl.RuleDefNoClauses         = [[ID]([{ParamDef ", "}*]) :- [Exp] -> [Exp].]        // desugared
  Decl.RuleDefNoParams          = [[ID] :- [Exp] -> [Exp],
  [{RuleClause ", "}+].]    // desugared
  Decl.RuleDefNoParamsNoClauses = [[ID] :- [Exp] -> [Exp].]    // desugared

  Decl.ClassDecl                = [[{DeclMod " "}*] class type [ID]]

context-free sorts RuleClause
context-free syntax
  RuleClause.WhereClause = <where <Exp>>

context-free sorts ModuleMod
context-free syntax
  // TODO: An external module may only contain external declarations
  // TODO: An external module should implicitly add `external` to its declarations
  ModuleMod.ExternModule = <extern>

context-free sorts DeclMod
context-free syntax
  // TODO: An external declaration cannot have a definition
  // TODO: An external declaration is implicitly public
  DeclMod.ExternDecl = <extern>
  // TODO: A public declaration cannot be imported
  DeclMod.PublicDecl = <public>

context-free sorts TypeParamDecl
context-free syntax
  TypeParamDecl.TypeParamDecl = <<ID>>

context-free sorts ParamDef
context-free syntax
  ParamDef.ParamDef = <<ID>: <Type>>
  ParamDef.ParamDefNoType = <<ID>>

context-free sorts Type
context-free syntax

  Type.TypeRef              = <<MOD_ID>>
  Type.MemberTypeRef        = <<Type>::<ID>>
  Type.ListType             = <[<Type>]>
  Type.StrategyType         = [([{Type ", "}*]) [Type] -> [Type]] {right}
  Type.StrategyTypeNoParams = [[Type] -> [Type]] {right} // desugared
  Type.AnyType              = <Any>     // FIXME: Make built-in
  Type.UnitType             = <Unit>    // FIXME: Make built-in
  Type.IntType              = <Int>     // FIXME: Make built-in
  Type.BoolType             = <Bool>    // FIXME: Make built-in
  Type.WldType              = <_>
  Type.TupleType            = <(<{Type ", "}+>)>
  Type                      = <(<Type>)> {bracket}

// Statix TYPE representation, for pretty-printing only:
context-free sorts TYPE
context-free syntax

  TYPE.STRATEGY             = [([{TYPE ", "}*]) [TYPE] -> [TYPE]]
  TYPE.CLASS                = [[ID]]
  TYPE.LIST                 = [List<[TYPE]>]
  TYPE.TUPLE                = [Tuple<[{TYPE ", "}+]>]

  TYPE.BYTE                 = [Byte]
  TYPE.SHORT                = [Short]
  TYPE.INT                  = [Int]
  TYPE.LONG                 = [Long]

  TYPE.UBYTE                = [UByte]
  TYPE.USHORT               = [UShort]
  TYPE.UINT                 = [UInt]
  TYPE.ULONG                = [ULong]

  TYPE.ANY                  = [Any]
  TYPE.BOOL                 = [Bool]
  TYPE.UNIT                 = [Unit]
  TYPE.STRING               = [String]

context-free sorts Exp Arg
context-free syntax

  Exp.Seq                       = <<Exp>; <Exp>> {right}
  Exp.Map                       = [[Exp] |> [Exp]] {right}        // desugared
  Exp.FlatMap                   = [[Exp] ||> [Exp]] {right}       // desugared
  Exp.Id                        = <id>
  Exp.Fail                      = <fail>
  Exp.Apply                     = [[Exp]([{Exp ", "}*])]
  Exp.Eval                      = [<[Exp]> [Exp]]
  Exp.Let                       = [let [ID] = [Exp],
[Exp]]
  Exp.Var                       = <<MOD_ID>>
  Exp.Member                    = <<Exp>::<ID>>
  Exp.ClassRef                  = <<Type>::<>class>
  Exp.Int = <<INT>>
  Exp.Object = <object>
  Exp.True = <true>
  Exp.False = <false>
  Exp.String = <<STRING>>
  Exp.Build = <!<Exp>>
  Exp.Tuple                     = <(<{Exp ", "}+>)>
  Exp                           = <(<Exp>)> {bracket}

  Exp.LambdaRule                = [\\([{ParamDef ", "}*]) :- [Exp] -> [Exp].\\]
  Exp.LambdaRuleNoParams        = [\\[Exp] -> [Exp].\\]    // desugared
  Exp.LambdaStrategy            = [\\([{ParamDef ", "}*]) = [Exp].\\]
  Exp.LambdaStrategyNoParams    = [\\= [Exp].\\]           // desugared


//context-free sorts Exp
//context-free syntax
//
//  Exp.Var = <<ID>>

//context-free priorities
  //Arg = Exp <0> .> Exp.Seq


context-free priorities
  {
    Exp.Apply
    Exp.Build
  } > {
    Exp.Map
    Exp.FlatMap
  } > {
    Exp.Seq
  }

context-free priorities
  {
    Type.StrategyType
  }

template options
  ID = keyword {reject}
  MOD_ID = keyword {reject}
  keyword -/- [A-Za-z0-9]
